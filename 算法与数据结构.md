# 串

## 数组填充

+ **预先**给数组**扩容**带填充后的大小，然后在**从后向前**进行操作：

    这样有两个好处：不用申请新数组；从后向前填充元素避免了从前先后填充元素那样 每次添加元素都要将添加元素之后的所有元素向后移动的问题。



## KMP

KMP 主要用在字符串匹配

+ **主要思想**：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配

+ **重点：**如何记录已经匹配的文本

    

+ <span style="font-size:20px">什么是前缀表</span>：

    **作用**：前缀表（next 数组）是用来回退的，记录了模式串与主串(*文本串* )不匹配时，模式串应该从哪里开始重新匹配

    例子：

    <img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="gif" style="zoom: 67%;" />

    以上图为例，匹配到模式串第 6 个字符`f`时发现不匹配。暴力匹配的话会从头开始匹配；但使用前缀表会从上次已经匹配的内容开始匹配，找到模式串第 3 个字符`b`开始匹配

    **本质**：记录下标`i`之前（包括`i`）的字符串中有多大长度的**相同前缀后缀**

    

+ <span style="font-size:20px">最长公共前后缀</span>：

    **前缀**：<span style="color:red">不包含</span>最后一个字符的所有以第一个字符开头的连续子串

    **后缀**：<span style="color:red">不包含</span>第一个字符的所有以最后一个字符结尾的连续子串

    **最长公共前后缀**：最大相同前缀后缀的长度，例如`a`的最长相等前后缀 0、`aa`为 1；`aaa`为 2。

    前缀表要求的就是相同前后缀的长度

    

+ <span style="font-size:20px">为什么要用前缀表</span>：

    理解为什么使用前缀表可以得知失配后跳到哪里匹配

    例子：依然以![image-20211022090217300](https://gitee.com/ethereal-bang/images/raw/master/20211022090217.png)

    为例，下标 5 之前的最大公共前后缀为`aa`长度为 2，因此从下标 2 字符`b`开始匹配，因为此时文本串的后缀与模式串的前缀相同

    

+ <span style="font-size:20px">计算前缀表</span>：

    求得的最长相同前后缀的长度就是对应前缀表的元素

    如图：![image-20211022094206178](https://gitee.com/ethereal-bang/images/raw/master/20211022094206.png)

    前缀表对应位置的数字表示的就是：下标`i`之前（包括`i`）的字符串中有多大长度的相同前后缀	==为什么不直接存不包括？==

    失配的位置要看它的前一个字符的前缀表的数值，把下标移动到下标`2`继续匹配

    

+ <span style="font-size:20px">前缀表与 next 数组</span>：

    很多 KMP 算法的实现都是使用 next 数组做回退操作，next 数组与前缀表有什么关系呢

    next 数组可以就是前缀表，但很多实现都是把前缀表统一减一（右移一位，初始位置 -1）之后作 next 数组

    至于为什么这样，并不涉及 KMP 的原理而是具体实现，两者均可。

    

+ <span style="font-size:20px">使用 next 数组匹配</span>：

    以下均已前缀表减一的 next 数组演示。



+ <span style="font-size:20px">构造 next 数组</span>：

    构造 next 数组其实是计算模式串`s`前缀表的过程：

    1. 初始化：

        ```js
        let j = -1;	// 前缀表统一减一
        next[0] = j; 
        ```

        next[i] 表示 i（包括i）之前最长相等的前后缀长度`j`。

    2. 处理前后缀不相同情况：

        

    3. 处理前后缀相同情况

    ==。。。==



### 查找子串

在一个串中查找是否出现另一个串，这是KMP的看家本领





# 堆

堆是用数组实现（*所以没有使用父/子指针*）的二叉树，根据“堆属性”来排序，“堆属性”决定树中节点位置。



**常用方法**：

+ 构建优先队列
+ 支持堆排序
+ 快速找出一个集合中最值



## 堆属性

堆分为两种：最大堆和最小堆，差别在于节点的排序方式。



最大堆中，父节点值比每个子节点的都大。这就是“堆属性”，且这个属性对堆中每个节点都成立，如：

<img src="https://gitee.com/ethereal-bang/images/raw/master/20211004170658.png" alt="image-20211004170651844" style="zoom:50%;" />

根据这一属性，最大堆总将最大值存放在数的根节点。堆属性非常有用，堆常被作为优先队列使用——可以快速访问到最重要元素

要注意，堆的根节点存放的是最值，但其他节点排序顺序未知



## 堆和普通树的区别

