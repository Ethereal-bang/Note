# 代码规范

**一个说明或一个语句占一行**

**当一句可执行语句结束的时候末尾需要有分号**

函数体内的语句要有明显缩进，**通常以按一下Tab键为一个缩进**



# 注释

 多行注释： /* 注释内容 */ 

 单行注释： // 注释一行                                                   

编程时给**变量或者函数起的名字就是标识符**

可以是**字母(A～Z，a～z)**、**数字(0～9)**、**下划线_**组成的字符串，并且**第一个字符必须是字母或下划线**

标识符是**严格区分大小写**

不要使用中文。标识符**不能是C语言的关键字**

C语言中的 32 个关键字：

 int float double char short long signed unsigned

if else switch case default for while do

break continue return void const sizeof struct typedef

static extern auto register enum goto union volatile



# 变量及赋值



![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601130418488-7e56505c-6644-43ba-8e02-4c5e9610008e.jpeg)

变量名和标识符的命名规范完全相同

不允许连续赋值

变量的赋值分为**两种方式**：

1.**先声明再赋值** 

2.**声明的同时赋值**![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601130543548-f7bac600-2dc4-418b-98f5-6418b141e372.jpeg)





**const常量：**

*Eg：const  int  a = 10;*

*或* *int  const  a = 10;*

const VS define

从功能上说它们确实很像，但它们又有明显的不同：

define是预编译指令，而const是普通变量的定义。define定义的宏是在预处理阶段展开的，而const定义的只读变量是在编译运行阶段使用的。

const定义的是变量，而define定义的是常量。define定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。但const定义的常变量本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，常变量是有名字的不变量，而常量是没有名字的。有名字就便于在程序中被引用，所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用const和define都可以的情况下尽量使用常变量来取代宏。

const定义的是变量，而宏定义的是常量，所以const定义的对象有数据类型，而宏定义的对象没有数据类型。所以编译器可以对前者进行类型安全检查，而对后者只是机械地进行字符替换，没有类型安全检查。这样就很容易出问题，即“边际问题”或者说是“括号问题”。



\#include <stdio.h>

int main()

{

int age;

age=18;/*这里定义年龄*/

printf("我今年%d岁！\n", age);

return 0;

}



## 变量的作用域

### 全局变量

使用情况：只读不写时

特点：

区别：定义的位置区分全局与局部



### 局部变量



## 变量的生存期



### 数据类型![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601130791217-47a41ef7-28b0-449a-aae2-1636e2ddda8c.jpeg)

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601130835342-38966f3b-fab1-45e6-b445-b306cfd34620.jpeg)

**%u**无符号十进制整数

**%lu**无符号长整型

%d有符号十进制整数

%0无符号八进制

%x无符号十六进制整数





## 格式化输出语句

**printf("输出格式符"，输出项);**

**
**![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601165732911-e6683680-1d28-45b7-baa1-007382c51954.jpeg)

当输出语句中包含普通字符时，可以采用一下格式：

**printf("普通字符输出格式符", 输出项);**![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601165875216-e4c311b2-b92c-4cf2-b261-777cb3414c00.jpeg)

注：printf语句自己占一行

Eg.

%7.1f:总共占七个位置；保留一位小数

%-7f：向后共占七个位置

![IMG_20200930_145407.jpg](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601450195504-3d5ffbe8-690f-4aab-b5cf-88dc9f1b0f38.jpeg?x-oss-process=image%2Fresize%2Cw_1500)

**scanf**函数也是有**返回值**的,它返回的是正确输入到变量的个数

*if(scanf("%d",&year)==1)*来判断输入数据是否为d



## 常量

分为**直接常量和符号常量**

符号常量在使用之前必须先定义，其一般形式为：

 **#define 标识符 常量值
**

符号常量的标示符一般习惯使用大写字母，变量的标示符一般习惯使用小写字母，加以区


![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601166581043-3184262f-b21b-4775-ac28-eb079cb15a82.jpeg)

## 类型转换

### 自动类型转换

自动转换发生在不同数据类型运算时字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换

> \#include <stdio.h>
>
> int main()
>
> {
>
> char c = 'a';
>
> int n = c ;    //将c赋值给n
>
> float f =  c;   //将c赋值给f
>
> double d =c;    //将c赋值给d
>
> printf("%d\n",n);
>
> printf("%f\n",f);
>
> printf("%lf\n",d);
>
> return 0;
>
> }
>
> 运行结果
>
> 97
>
> 97.000000
>
> 97.000000



### 强制类型转换

一般形式为：

 **(数据类型) (表达式)**

转换后不会改变原数据的类型及变量值，只在本次运算中**临时性转换**

强制转换后的运算结果**不遵循四舍五入原则**



# 输入和输出

## 单个字符的输入和输出

``` c
a = getchar();	// 从键盘输入一个字符，回车键结束输入，存入变量 a

putchar('\n');
```



## 格式化输入和输出



# 运算符号

+、-、*、/


![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601281519551-4a64587b-0e64-4cbe-b55b-063bc8210f71.jpeg)

除法运算中**两个数都是整数**的话，则**结果也为整数**

两数中**有一个为小数**，**结果则为小数**



**取余****运算**中**只适合用两个整数**进行取余运算

运算后的符号取决于被模数的符号

## 自增与自减运算符

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601282351052-a8a36233-99e6-4fe9-b789-630a9c3f27b7.jpeg)

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601282367487-030abec9-3ea3-497d-a6df-7e2517c8173a.jpeg)

运行结果![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601282396961-579a0703-b982-4d5b-9950-ce49a4f4e4bc.jpeg)

## 赋值运算符

**简单赋值运算符**和**复合赋值运算符**

复合赋值运算符就是在简单赋值符“=”之前加上其它运算符构成

**a += 5;这个算式就等价于a = a+5;** 将变量a和5相加之后再赋值给a

复合运算符中运算符和等号之间是不存在空格的

## 关系运算符![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601282737574-1d7a1a4b-491f-4b09-bcc2-c73821976511.jpeg)

关系表达式的值是“真”和“假”，在C程序用整数1和0表示

## 逻辑运算符![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601282889902-51b079df-888f-405f-adef-9e67ea0a5098.jpeg)

懒惰求值法&&和||

![IMG_20201021_144433.jpg](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1603262712407-a3ac0dfa-9387-40ad-99a3-de498d5df024.jpeg?x-oss-process=image%2Fresize%2Cw_1500)

## 三目运算符

三目运算符：“?:”，其格式为： **表达式1 ? 表达式2 : 表达式3;** 

执行过程是：

先判断表达式1的值是否为真，如果是真的话执行表达式2；如果是假的话执行表达式3

\#include <stdio.h>

int main()

{

//定义小编兜里的钱

double money =12    ;

//定义打车回家的费用

double cost =  11.5   ;

printf("小编能不能打车回家呢：");

//输出y小编就打车回家了，输出n小编就不能打车回家

printf("%c", money>=cost?'y':'n'            );

return 0;

}

执行结果为： 小编能不能打车回家呢：y



## 运算符优先级比较

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601283849137-016483d7-d8c4-42a6-a431-866b45885ed7.jpeg)

C语言中运算符中最高等级的为()



# 结构

## 分支结构

### if 语句

<span style='font-size: 20px'>简单 if 语句</span>

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601284403645-e24bb022-8d68-4c78-bbf1-09576ca06722.jpeg)

if()后面没有分号，直接写{}，else后面也没有分号，直接写{}

注：

表达式非0就输出

只有一个语句而不是语句块时可省略花括号

![IMG_20201021_145901.jpg](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1603263681908-3c72e3ba-9c6f-4260-80f4-879797bad19e.jpeg?x-oss-process=image%2Fresize%2Cw_1500)



<span style='font-size: 20px'>多重 if 语句</span>

**依次判断表达式的值，当出现某个值为真时，则执行对应代码块，否则执行下一代码块**

当某一条件为真的时候，则不会向下执行该分支结构的其他语句

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601285256652-9fda519c-8142-4710-a8f2-63ca680b88ae.jpeg)

**关系运算符**：![IMG_20201021_143302.jpg](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1603262006489-96780410-a068-412a-846b-0de63ec6d5a6.jpeg?x-oss-process=image%2Fresize%2Cw_1500)



<span style='font-size: 20px'>嵌套if-else语句</span>

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601285392440-e7928596-f6f1-41f3-86ab-a2d234b38c6c.jpeg)

一般多分支分到else里面

![IMG_20201021_144223.jpg](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1603262582092-a0bbe19c-dd88-4f3d-9ce9-a59b0a6e3b41.jpeg?x-oss-process=image%2Fresize%2Cw_1500)

n为scanf的返回值，若输入year不为数字类型，则返回值为非1的数



### switch语句

作用：多分支选择

 ``` c
switch(x>0)
{      
    case 1:printf("+\n");
	       break;
    case 0:printf("-\n");
	       break;
}
 ```



![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1604060317552-06b489ec-b635-45bb-bf96-c60a06e5ec9b.jpeg)

执行顺序


![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1604060355055-a4a96de3-ff11-477b-afe5-c2c8746c108d.jpeg)

注

**case**子句后如果没有**break**;会一直往后执行一直到遇到break;才会跳出switch语句

case后，允许有多个语句，{}可省

各case和default子句的先后顺序可以变动，而不会影响程序执行结果

default子句可以省略不用

Eg

![image.png](https://cdn.nlark.com/yuque/0/2020/png/2617721/1604060489954-018b91bd-7b28-4f48-9c3c-5f05130dcad1.png)



## 循环结构

### while

注意以下几点：

1、while语句中的**表达式一般是关系表达或逻辑表达式**，当表达式的值为假时不执行循环体，反之则循环体一直执行。

2、一定要记着**在循环体中改变循环变量的值**，否则会出现死循环（无休止的执行）。

3、循环体如果包括有一个以上的语句，则**必须用{}括起来**，组成复合语句。

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601286169630-ad79c9fb-1a5c-43ba-9e5b-a7a40b966225.jpeg)

### do-while循环

Eg：

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601986574851-56c5f601-f974-4610-b79f-e508910e4e8f.jpeg)

**do-while循环至少要执行一次循环语句**

**先执行再循环**

注意：使用do-while结构语句时，while括号后必须有**分号**

### for循环

特点：相对前两种循环结构语法更直接、简单

一般形式：

[![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1601987076079-4f9821ac-03e1-488b-882e-0c120735492c.jpeg)](http://img.mukewang.com/54890cf000013b1303130095.jpg)

执行过程

第一步：执行表达式1(**赋值**语句），对循环变量做初始化；

第二步：判断表达式2（**判断**语句，若其值为真（非0），则执行for循环体中执行代码块，然后向下执行；若其值为假（0），则结束循环；

第三步：执行表达式3**（步进值）**；

第四步：执行第二步；

第五步：循环结束，程序继续向下执行

注意for循环中的分号

图示

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1602644319621-c922ed2b-a60e-4d1b-9ba3-51a80a4c8f80.jpeg)

Eg

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1602644601327-85176f41-a0c3-4e0a-a20d-9e85d15ab2d1.jpeg)

注意

1、for循环中的“表达式1、2、3”均可可以缺省（缺少，省略），但分号(**;**)不能缺省。

2、省略“表达式1（**循环变量赋初值**）”，表示不对循环变量赋初始值

3、省略“表达式2(**循环条件**)”，不做其它处理，循环一直执行（死循环

4、省略“表达式3(**循环变量增量**)”，不做其他处理，循环一直执行（死循环）

（死循环可以使用后面即将讲到的**break**解决）

5、表达式1可以是设置循环变量的初值的赋值表达式，也可以是其他表达式

6、表达式1和表达式3可以是一个简单表达式也可以是多个表达式以逗号分割

eg

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1602645023289-51ef8cd4-ce34-42c0-afcf-3b83573075f4.jpeg)运行结果![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1602645066977-b08c13ed-c719-46f9-9161-14ebe55aa972.jpeg)



7、表达式2一般是关系表达式或逻辑表达式，但也可是数值表达式或字符表达式，只要其值非零，就执行循环体。

8、各表达式中的变量一定要在for循环之前定义

### 循环结构之三种循环比较

使用场合区别

1、在**知循环次数**的情况下更适合使用**for**循环；

2、在**不知循环次数**的情况下适合使用**while**或者**do-while**循环

如果**可能一次都不循环**应考虑使用**while**循环，如果**至少循环一****次**应考虑使用**do-while**循环

本质三种循环之间是可以相互**转换**的

eg

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1602645387966-cccd2ec9-ebfd-4f7d-b4c6-5532f18fdc42.jpeg)

### 多重嵌套循环

定义在循环结构的循环体中又出现循环结构

外层循环为父循环，内层循环为子循环，父循环一次，子循环需要全部执行完，直到跳出循环。父循环再进入下一次，子循环继续执行...

图解

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1602647054433-8057347d-3c8e-4f7f-96ff-4914f7658bf9.jpeg)

注一个父循环可以有多个子循环

Eg


![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1602647368862-f5dc5586-1565-40c1-ad06-02ffd2ec1e1b.jpeg)![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1602647375305-0776d5cd-0d90-46f6-af68-5398de0686dc.jpeg)

 

## 结束语句

### break语句

1、在没有**循环结构**的情况下，break不能用在单独的if-else语句中。

2、在多层循环中，一个break语句**只跳出当前循环**

**Eg**

**
**![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1602647654358-f1460c77-8aa6-401e-bf39-fd8a246df532.jpeg)![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1602647709767-89feaf20-612b-4036-b920-c09715eaf3b2.jpeg)



### continue语句

作用**中断后继续**

break与continue的区别：break是跳出当前整个循环，continue结束本次循环开始下一次循环



#  函数

## 主函数

在最新的C标准中，main函数前的类型为int而不是void

main前面的int就是主函数的类型



## 数学函数

\#include<math.h>	// 包含数学函数的库

**次方**  **pow(x,y)**  (计算x的y次方）

**绝对值**   **fabs(x)**  (取x的绝对值）

...



## 定义函数

自定义函数的一般形式：

![image](https://cdn.nlark.com/yuque/0/2020/jpeg/2617721/1607166647643-78d12bc7-e84a-49ef-88e6-e26dc497c326.jpeg)

位置

放在main函数后面的话，需要在main函数前声明自定义函数，

声明格式为：**[返回值数据类型说明] 函数名称（参数数据类型 参数）;       参数可省略**



## 函数调用

函数调用的一般形式为：

**函数名（参数）;** 

**注**

1、对**无参函数**调用的时候可以将[]包含的省略。

无参函数中输出的相对就比较固定

有参函数更为灵活

2、**[]中**可以是常数，变量或其它构造类型数据及表达式，各参数之间用逗号分隔。

函数内的参数与主函数无关，不通用

**多函数程序**

```
void main()//循环根据用户选择调用每一个函数
{ 
    int a[N];
    ……
    Read(a,N); //输入
    do{ 
        printf(“请输入：1－求和，2－排序，3－查找…… 0-退出”);
        scanf(“%d”,&choose);
        switch(choose)  //根据选择调用不同函数
        {
            case 1: //调用求和函数            
            case 2: //调用排序函数
            case 3: //调用查找函数　　　　　　
            ……
            case 0:
                printf("谢谢您的使用！再见！");               
                exit(0); //调用exit函数结束程序             
                break;  
        }   
    }while(1);//do-while结束
}
void Read(int a[], int n)　// 第一个函数定义{……}
int Average(int a[], int n)　　 // 第二个函数定义{……}
```



## 递归函数

定义

递归与迭代区别



# 数组

## 数组的定义和初始化

### 一维数组

 格式：元素类型 数组名[元素个数] 

``` c
int a[5] = {1, 2, 3, 4, 5};	// 初始化
```



元素个数即数组长度

定义时可适量大一些，实际可不用完



### 二维数组

**格式**：**`类型 数组名[第一维长度][第二维长度];`**	（*先行后列*）

``` c
short matrix[3][4];
```

上式定义了`3` 行`4`列的短整型元素数组。



| 行地址 \ 列地址 |          |          |
| :-------------: | -------- | -------- |
|      a[0]       | a\[0][0] | a\[0][1] |
|      a[1]       | a\[1][0] | a\[1][1] |

声明二维数组时，第一个长度可省略，但第二维长度不能够省略

``` c
short matrix[][4] = { {1, 2}, {2, 3, 4} };	// 其他元素默认初始化为 0
```



## 数组作函数实参

形参看似是一个数组，实则是一个变量——存储数组的**首地址**

实参传首地址的原因：只传一个地址比拷贝数组所有数据**效率更高**



**不需返回**该数组，因为函数中直接操作主函数内该数组



```c
#include<stdio.h>
#define N 4
//函数
float Average(int a[], int n) { //第一个实参传给函数的只是a数组的首地址；在参数位置 看似定义了数组实则定义了一个地址变量a
                                //n是传的数组长度
}

int main() {
    int num, a[N];
    // ...
    Avreage(a, num);	// 调用函数
}
```

**调用函数**时，只需传参数组名，不需长度声明

一维数组作函数参数时可省略长度声明



当形参被声明为**二维数组**时，可以省略数组第一维**长度声明**，但不能省略数组第二维的长度声明

``` c
// 函数功能：输入n个学生的学号和三门课的成绩
void  ReadScore(int score[][])

// 调用函数
ReadScore(score[][COURSE_N])	// 二维数组传参时必须传二维数组形式
```

不同于一维数组传参时传入首地址就可，（*如 `a`*）

## 数组的常见应用

[课件](https://docs.qq.com/slide/DRm9sU3luRktUdEhy?m_readonly=1&xiaolv_wy_tdoc_tid=393158239_1609308445363&tdsourcetag=s_qq_file_preview&scene=gAFfg4lAFfg40BFfg4BAFfg4Fbo2n1&_t=1609308716802)

### 统计：

求和，统计数量 等

### 求最值（下标）

### 查找

#### 顺序查找

```
//函数功能：用顺序查找法在具有n个元素的数组a中查找x,返回第一次出现的下标
int  Search( int a[], int n, int x) {
    int i;   
    for (i=0; i<n; i++) {
        if (a[i] == x) {
            return (i);//找到返回下标
        }
    }    
return (-1);//没找到返回-1}
```

#### 二分法查找

- - - 对数组排序  *此处以从小到大为例*
    - 先找到查找区域中点，

1. 1. 1. 中间值比目标值小：说明目标值在右半边
      2. ​                      大：                    左
      3. ​                      等：                    找到

```
//函数功能：用二分法在具有n个元素的数组a中查找x,返回第一次出现的下标
int BinSearch_( int a[],int n,int to_search) {
    int left=0,right=n-1,mid, find_i=-1;//标志变量   
    /*当还有区域没找，而且还未找到的时候循环查找*/
    while (left <= right&&find_i==-1) {
        mid = (left + right) / 2; /*求区域的中点*/
        if (to_search > a[mid]) { /*重新设定左边界*/
            left = mid + 1;
        }       
        else  if (to_search < a[mid]) { /*重新设定右边界*/ 
            right = mid - 1;
        }       　    
        else { /*找到，结束*/
            find_i=mid;
        }   
    }   
    return find_i;
}
```

### 排序

*下面均以 从小到大排序 为例*

#### 冒泡排序  

```c
//函数功能：用冒
泡法对有n个数组元素的数组a进行排序
void Sort_bubble(int a[],int n){
    int i,j,temp;
    for(i=1; i<n; i++)  /*冒泡法排序，i控制趟数*/
        for(j=0; j<n-i; j++)
            if(a[j]>a[j+1])   //前后两个元素比较、交换
            {
                temp=a[j]; a[j]=a[j+1];a[j+1]=temp; //俩俩交换
            }
}
```

解释  把每次外层循环比较出的最大值元素通过**若干次俩俩交换到后面**

每次内层循环(俩俩比较)的 终止下标 减少

- - 第1趟排序：比较a[0]和a[1]，不满足顺序交换，再比较a[1]和a[2]，不满足顺序交换，依此类推，直至a[n-2]和a[n-1]比较，不满足顺序交换，通过这一趟的两两比较**找到第****1****个最大的数放在****a[n-1]***最后一个***的位置**
  - ……  
  - 第i趟排序：比较a[0]和a[1]，不满足顺序交换，再比较a[1]和a[2]，不满足顺序交换，依此类推，直至a[n-i-1]和a[n-i]比较，不满足顺序交换，通过这一趟的两两比较找到第i个最大的数放在a[n-i]的位置
  - 直至第n-1趟

注排序函数不需返回值：因为根据形参a找到的数组和主函数中的数组是同一个数组，a[i]就是score[i],所以，对a进行排序，实际上就是对主函数中的score数组进行排序。因此不需要返回。



#### 交换排序

解释    起始元素与后面所有元素比较、交换

把每次外层循环比较得到的最小值元素通过**若干次俩俩交换到前面**

每次内层循环的 起始下标 增加

```
void Sort_Exchange (int a[],int n)
{
    int i,j,temp;
    for(i=0; i<n-1; i++) // i控制趟数
    {
        for(j=i+1; j<n; j++)
            if(a[i]>a[j]) //交换
            {
                temp=a[i]; a[i]=a[j]; a[j]=temp;
            }
    }
}
```

#### 选择排序

解释    先找到最小值下标，不忙交换  *区别于交换法：循环结构相似，交换次数更少*

```
void Sort_select(int a[],int n)
{
    int i,j,min_i,temp;
    for(i=0;i<n-1;i++)    // i控制趟数
    {
        min_i=i;    // 初始化最小元素下标
      for(j=i+1;j<n;j++)// 找到剩余元素里最小的
          if(a[j]<a[min_i]) //若从大到小排序，改成>
          {
              min_i=j;
          } 
      if(min_i! =i)      //交换
      {
          temp=a[min_i]; a[min_i]=a[i]; a[i]=temp;
      }
}
```



### 插入

#### 插入到特定位置

```
int Insert_to_pos(int a[],int n,int num,int pos)
{
    int i;
    if(pos>=n)
    {
        printf("wrong position");
    }
    else
    {  //从最后一个元素开始，到a[i]，所有元素向后移；
        for(i=n-1;i>=pos;i--)
        a[i+1]=a[i];    
        a[pos]=num;
    }
    return n+1; 
}
```


/

#### 按顺序插入

```
int Insert_to_sortedarray(int a[],int n,int num)// (a已按从小到大排好) 
{
    int i;
    for(i=0;num>a[i]&&i<n;i++);
// 找到插入的位置i
    n=Insert_to_pos(a,n,num,i);
// 调用函数插入到a[i]所在的位置
    return n;
}
```

### 删除

```
// 函数功能：删除a数组中值为num的元素
int Delete_num(int a[], int n, int num) {
    int i, j, n;
    for(i = 0; i < n; i++) {
        if(a[i] == num) {
            // 从被找到元素的下一个开始从后往前移
            for(j = i; j < n-1; j++) {
                a[j] = a[j+1];
        }
    i--;    // 让下一次查找从这次的删除位置开始，以防连续俩个目标值元素的情况（重难点）
    n--;    // 每删除一个元素，数组长度-1
    }
}
```



# 指针

## 指针变量的定义和初始化

**指针变量**：存放变量的地址需要一种特殊类型的变量，这种特殊的数据类型就是 指针

**格式**：**`类型关键字 * 指针变量名 `**

```c
float *pa = NULL, *pb = NULL;
```

忘记指针初始化会给系统带来潜在危险，因此习惯上在定义指针变量的同时将其初始化为`NULL` 



也可直接初始化指向地址。

```c
int *pa = &a;
// 等价于

int *pa;
pa = &a;
```

上面俩种写法都初始化了指针变量`pa`，使其指向`a`

## 间接寻址运算符

通过指针变量间接存取它所指向的变量的访问方式称为：**间接寻址**



获取变量的地址需要使用**取地址运算符`&`**



指针运算符也称间接寻址运算符，即**`*`**。间接寻址运算符用来**获取指针变量指向的变量的值***

```c
int a = 8;
int *pa = &a;
*pa = 9;

printf("%d", a);	// 9
```

以上代码是修改指针变量`pa`所指向的变量的值，**区别于初始化**。



**指针变量前面有无`*`的区别**：

`*`用来访问指针变量指向的变量的值。不加`*`就是该指针变量的地址。

简单理解：**加`*`是值，不加`*`是地址**



## 指针变量作函数参数

普通变量作函数参数是一种**按值调用**，形参就是实参的复印件，函数形参值的改变不能影响实参值



指针变量作函数参数，传给被调函数的值不是变量的值，而是变量的地址，称为 模拟按引用调用



以下是一个指针变量实现调换俩个变量的值的例子。

![image-20210308230554600](https://i.loli.net/2021/03/08/UxcRAX5f2zYE7aG.png)



注意，向其传参时要在变量前使用**取地址运算符**`&`



## 函数指针

函数指针即指向函数的指针。

类比数组可知，函数名就是这个函数在内存中的起始地址。编译器将不带`()`的函数名解释为该函数的入口地址

下面的例子。

``` c
void SelectionSort(int a[], int n, int (*compare) (int a, int b))
{
    // 函数功能：调用函数指针compare指向的函数实现对数组a的交换排序
}
/* 函数功能：使数据按升序排序 */
int Ascending(int a, int b)
{
    return a < b;
}
/* 函数功能：使数据按降序排序 */
int Decending(int a, int b) 
{
    return a > b
}


int main() 
{
    // ...
    SelectionSort(score, n, Ascending);
    // ...
    SelectionSort(score, n, Descending);
}
```

上面代码中`int (*compare) (int a, int b)`中的`a`、`b`是该指针函数的参数。



# 指针和数组

## 指针处理数组

### 指针对一维数组的处理

<span style="font-size:20px">数组元素引用方式</span>

<hr>

总结：

​	a[i]或\*(a+i)
​	p[i]或\*(p+i)
​	*(p++)

1. 数组名 + 下标

    `a[i]`

2. 数组名 + 偏移量

    ``` c
    int a[4];
    
    for(i = 0; i < 10; i++)
        scanf("%d", a+i);	// 因为 a 本身就表示地址，所以前面不用加取地址运算符 &
    for(i = 0; i < 10; i++)
        printf("%d", *(a+i));	// 输出 a+i 地址存储的值
    ```

<img src="https://i.loli.net/2021/04/12/nizpBJkQZgYT2G4.png" alt="image-20210412081709481" style="zoom:20%;" />



3. 指针变量 + 下标

    ``` c
    int a[10];
    int *p = a;	// 这时候 p 就指向了 a 数组，所以后面能直接用 p[i]
    int i;
    
    for (i = 0; i < 10; i++)
        scanf("%d", &p[i] );
    for (i = 0; i < 10; i++)
        printf("%d", p[i] );
    ```

    `p`和`a`的区别：数组名`a`是个常量，没有内存空间，定义数组`a`申请的 10 个空间都分配给了`a[0]`至`a[9]`；而`p`有相应的内存空间。（*但这种方式与方式一相比没有区别*）



4. 指针变量 + 偏移量

    ``` c
    // 其余代码同上例
    
    scanf("%d", p+i);
    printf("%d", *(p+i) );
    ```



5. 指针变量

    ``` c
    int a[10];
    int *p = NULL;
    
    for (p = a; p < a+10; p++)	// 注意：是 a+10不是 10，因为 p 要对应地址而不是某个数
        scanf("%d", p);
    for (p = a; p < a+10; p++)
        printf("%d", *p);
    ```




关于数组名和指针名地址分配，下例。

``` c
char *a = "hello";	
char b[] = "hello";	
```

上例中，因为为`b[i]`申请了内存，`b[i]`就是变量。但系统没有为`b`申请内存，所以`b`是常量。因此，可以为`b[i]`赋新值，不能为`b`赋新值；  

前者只为`a`申请 1 个内存空间储存**字符串常量首地址**，`a`是常量。因为没有为`a[i]`申请内存，所以`a[i]`都是常量。因此，可以为`a`赋新值，不能为`a[i]`赋新值。



### 指针对二维数组的处理

<span style="font-size:20px">取址规则：</span>

1. 地址加减一个整数不改变地址类型。行地址加一还是行地址，列地址同理。

2. 列地址取值得元素值，行地址取值转换成列地址

3. 列地址加一跳一元素，行地址加一跳一行

例子：

+ **`b`**：                                     行地址，
+ **`b+i`**：                                 行地址，指向第`i`行首地址
+ **`*(b+i)` / `b[i]`**：              列地址，第`i`行第 0 列地址
+ **`*(b+i)+j` / `b[i]+j`**：      列地址，第`i`行`j`列地址
+ **`*((b+i)+j)` / `b[i][j]`**：数组元素，第`i`行第`j`列元素



<span style="font-size:22px">指针指向二维数组的两种指针：</span>

#### 列指针

列指针指向二维数组的每一个元素，它每加 1，指向二维数组的下一个数组元素。它将二维数组看成一个一维数组。



定义方式及取值：

``` c
int b[M][N];

int *p = &b[0][0];
// 或
int *q = b[0];
```

两种方式皆可，总之是列地址。  
其中`b[i][j]`相对于数组起始地址的偏移量为`i*N+j`。则`p[i*N+j]` / `*(p + i*N+j)`表示每一个数组元素。



#### 行指针

行指针指向二维数组的行，它每加 1，指向二维数组的下一行

定义：格式，**类型 （\*行指针名) [常量 N] **

``` c
int (*P) [3];

/* 指向数组，用行地址初始化 */
p =  b;
// 或
p = &b[0];	// ？
```

含义：定义一个指针变量`p`，用于指向一行且每行 3 个元素。



### 指针运算——地址运算

主要用于对数组的处理。

+ <span style="font-size:20px">单个指针的运算</span>

    加减一个数表示数据单元的移动,如`p++`、`--p`、`p = p+n`

    表达式的区分深入理解见下例，

    ``` c
    	int  a[] = {1,2,3,4,5};
    	int  *p = a;
    	
    	printf("%d,", *p);		// 1 
    	printf("%d,", *(++p));	// 2
    	printf("%d,", *++p);	// 3
    	printf("%d,", *(p--));	// 3 
    	printf("%d,", *p++);	// 2
    	printf("%d,", *p);		// 3
    	printf("%d,", ++(*p));	// 4 此时 p[3] 的值已经从 3 加为 4
    	printf("%d,", *p);		// 4
    ```

    + p++：指向下一地址单元
    + 
    + *p++：先取`p`指向的数据单元的值后，`p`再指向下一地址单元
    + *(p++)：同上，虽然＋＋括在括号里，但由于＋＋在后边，因此仍然后加
    + *(++p)：上面的顺序颠转
    + (*p)++：取值`p`指向的数据后，该数据 +1

+ <span style="font-size:20px">两个指针的运算</span>

    比较运算：用来比较两个指针前后位置

    相减：求出两个指针相距多远



## 指针数组

**定义**：若干类型相同的指针所构成的数组

**定义形式**：**类型关键字 \*数组名[数组长度]**。

``` c
char *pStr[5];
```

上例，区别于行指针`char (*pStr) [5]`。



注意，因指针数组的元素是指针，所以与指针变量一样，**使用指针数组前必须对数组元素进行初始化**。

**初始化**有两种方式：

1. 与普通数组

2. 类似，但元素要是指针（*/地址*）

3. 字符串字面量初始化。

    ``` c
    char *pStr[N] = {"America", "China", "Japan"};
    ```

    使用字符串字面量初始化时，每个字符串字面量在内存中所占的存储空间大小与其实际长度相同，因此这种情况下可以节省内存。



**应用**

1. 指针数组对多个字符串进行处理操作
2. 指针数组用于表示命令行参数  ==？==



## 动态数组

指针的另一个重要应用是把**指针与动态内存分配函数**联用，使得**动态数组**成为可能。

**动态内存分配**是在程序运行时为变量分配内存的一种方法，有时在程序运行中需要数量可变的内存空间，即在运行时才能确定要用多少个字节的内存来存放数据。



在程序运行过程中根据用户的需求生成长度可变的动态数组要用到以下动态分配函数



### 动态分配函数

以下函数均在头文件 **<stdlib.h>**中。

+ <span style="font-size:20px">malloc()</span>

    <hr>

    函数`malloc()`用于**分配若干字节的内存空间**，**返回一指向该内存首地址的指针**	==？==

    

    函数`malloc()`的原型为：

    ``` c
    void *malloc(unsigned int size);
    ```

    + **`void *`**是无类型指针，用来说明其基类型未知的指针。因此，若要将函数调用的返回值赋予某个指针，则应先根据该指针基类型，用**强转**的方法将返回的指针值强转为所需类型.

        ``` c
        int *pi = NULL;
        pi = (int *)malloc(2);
        ```

    + **`size`**是向系统申请空间的大小，若不能确定某种类型所占内存字节数==？==，则需要使用`sizeof()`计算本系统中该类型所占内存字节数

        ``` c
        int *pi = NULL;
        pi = (int *)malloc(sizeof(int));
        ```

+ <span style="font-size:20px">calloc()</span>

    <hr>

    函数`calloc()`用于给若干同一类型的数据项**分配连续的存储空间**并赋值为 0 ==不赋会怎样？==

    

    `calloc()`函数原型为：

    ``` c
    void *calloc(unsigned int num, unsigned int size);
    ```

    `calloc()`相当于声明一个一维数组，  
    其中**`num`**表示向系统申请的**内存空间数量**，决定了一维数组大小；  
    **`size`**表示申请的**每个空间的字节数**，确定了数组元素的类型。  
    而函数返回值就是数组的首地址。

    例子。

    ``` c
    float *pf = NULL;
    pf = (float *)calloc(10, sizeof(float));
    ```

    上例表示向系统申请 10 个连续的`float`型存储单元，并用指针`pf`指向该连续内存的首地址。（系统申请的总内存字节数是 10 x sizeof(float)  ） 

+ <span style="font-size:20px">free()</span>

    <hr>

    函数`free()`的功能是释放向系统动态申请的指针`p`指向的存储空间

    

    原型为

    ``` c
    void free(void *p);
    ```

    该函数无返回值，`p`只能是由`malloc()`或`calloc()`申请内存时返回的地址.

+ <span style="font-size:20px">realloc()</span>

    <hr>

    函数`realloc()`用于改变原来分配的存储空间的大小

    

    原型为：

    ``` c
    void *realloc(void *p, unsigned int size);
    ```

    函数将指针`p`指向的存储空间大小改为`size`个字节，函数返回新分配的存储空间的首地址，不一定与原来分配的首地址相同

    

    由于动态内存分配的存储单元是无名的，只能通过指针变量来引用。所以一旦改变了指针的指向，原来分配的内存及数据就消失了。因此**不要轻易改变指针变量的值**。



以下是利用动态数组的实例。==。。。==

+ 长度可变的一维动态数组



# 字符串

为便于确定字符串的长度，C 编译器会自动在字符串的末尾添加一个 ASCII 码值为 0 的空操作符`\0`作为字符串结束的标志，在字符串中可以不显示地写出。

因此，字符串实际就是由若干个字符构成且以`\0`作为结束的一个字符序列



字符串的**存储**：`\0`也占一个字节的内存，但它不计入字符串的实际长度，只计入数组的长度。  
所以，数组定义的长度应该大于等于字符串中包括`\0`在内的字符个数.



## 字符数组初始化

<span style='font-size: 20px'>字符串常量</span>

------

推荐以下写法。

``` c
char a[30] = "I U.";
```

一般用字符串常量对字符数组初始化，系统会自动在末尾加**结束字符`\0`**

> 字符串字面量，有时也称为字符串常量，它是由一对双引号括起来的一个字符序列。
>
> 注意，字符串字面量不同于字符常量。

若字符串太长，无法写在一行中，则可将其拆分成几个小的片段写在不同行中。例如。

``` c
char longStr[] = "This is the first half of the string"
    			"and this is the second half";
// This is the first half of the stringand this is the second half
```



<span style = 'font-size: 20px'>单个输入</span>

<hr>

``` c
char a[30] = {'I', '', 'U', '.'};
```

这种写法不会自动加`\0`，不易判断字符串结束位置。

只有下面这样写才代表一个字符串。

``` c
char a[30] = {'I', '', 'U', '.', '\0'};
```



## 字符串的输入输出

<span style='font-size: 19px'>输入</span>

<hr>

``` c
#include<stdio.h>
int main() {
    int i, number = 0;
    char a[30];
    puts("please input a string:");
    gets(a);	// 一次性输入字符串，存入a数组
    for(i = 0; a[i] !=) {	// 统计
        if((a[i] >= 'a' && a[i] <= 'z') || (a[i] >= 'A' && a[i] >= 'Z') {
            // ...
        }
    }
}
```

`scanf("%s", a);`实现输入的话，`a`前面不需要`&`，因为此时`a`是数组名，表示数组首地址。

要想输入带空格的字符串，只能用`gets()`



注意，使用`scanf`前一定要注意`getchar()`读走输入缓冲区中的回车符



<span style='font-size: 20px'>输出</span>

<hr>

`puts()`函数输出字符串：

``` c
char name[] = 'Jack';
puts(name);
```

函数`puts()`用于从参数首地址开始依次输出存储单元中的字符，当遇到第一个`\0`时输出结束，并且自动输出一个**换行符**。

唯一的不足是不能在输出行中增加一些其他信息。

``` c
char name[] = 'Jack';
printf("My name is %s", name);
```



## 应用

<span style='font-size: 20px'>查找字符在字符串中出现的位置</span>

算法：

1. **定义**字符数组用来存储字符串
2. **查找**（写成函数）
3. **输出**查找结果

注意：查找，循环条件：`a[i] != '\0'`



<span style='font-size: 20px'>判断回文数</span>

算法：

![image-20210322091936098](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210322091936098.png)



循环条件`i < j && equal = 1`，`equal`初始化为 1，判断出不是回文则变为 0。



## 字符串有关库函数

在`<string.h>`中定义了若干专门的字符串处理函数	

<span style = 'font-size: 19px'>strlen(字符串)</span>

返回字符串实际长度，即不包括`'\0'`的实际字符个数



<span style = 'font-size: 19px'>strcpy(str1，str2)</span>

将`str2`复制给`str1`



<span style = 'font-size: 19px'>strcat(str1，str2)</span>

把 `str2` 连到 `str1`后面。



<span style = 'font-size: 19px'>strcmp(字符串1， 字符串2)</span>

当出现第一对不相等的字符时，就由这两个字符决定所在字符串的大小
返回其ASCII码比较的结果值，  

+ 若`str1` < `str2`，返回值 < 0
+ 若`str1` > `str2`，返回值 > 0
+ 若`str1` = `str2`，返回值 = 0



注意：

+ 字符串不能直接整体复制（也就是运算符）
+ 字符串不能用关系运算符比较大小

以上可用库函数来实现。



## 二维数组存储多个字符串

当用二维字符数组存放多个字符串时，数组第一维长度代表要存储的字符串的个数，可以省略，但是第二维的长度不能省略，应**按最长的字符串长度设定数组第二维的长度**。注意：要算上`\0`占的长度。

``` c
char weekday[][10] = {"Sunday", "Monday", "Tuesday"};
```



## 字符指针



# 结构体和数据结构基础

## 结构体

结构体将不同类型的数据成员组织到统一的名字之下，适合于对逻辑相关、属性不同（*或相同*）的数据进行处理。



+ <span style="font-size:20px">结构体变量的定义</span>

    <hr>

    以学生成绩管理系统为例。

    1. 首先**声明一个结构体模板**。

        ``` c
        struct student
        {
            long stuID;		// 学号
            char stuName;	// 姓名
            int score[4];	// 4 门课程成绩
        };
        ```

        注意末尾的`;`一定不能忘记，是结构体声明的结束标志。

    2. 利用已经定义好的结构体数据类型来**定义结构体变量**。有两种方式。

        + 先声明结构体模板，再定义结构体变量

            ``` c
            struct student stu1;	// 定义了一个具有 struct student 类型的结构变量 stu1
            ```

        + 声明结构体模板的同时定义结构体变量

            ``` c
            struct student
            {
                long stuID;		// 学号
                char stuName;	// 姓名
                int score[4];	// 4 门课程成绩
            }stu2;
            ```

    3. **typedef**定义数据类型

        关键字`typedef`可为自定义的数据类型定义一个别名。数据类型的别名通常使用**大写字母**，与已有的数据类型相区分

        如上例，有两种方式为`struct student`定义新的名字。

        ``` c
        /* 第一种 */
        typedef struct student 
        {
            long stuId;
            char stuName[10];	
            int score[4];	
        }STUDENT;
        
        // 第二种
        typedef struct student STUDENT;
        ```

        二者都为`struct student`结构体类型定义了一个新的名字`STUDENT`，即`STUDENT`与`struct student`是同义词。  
        因此，用它们定义结构体变量也是一样的  

        ``` c
        STUDENT stu1, stu2;	// 写法更简洁
        // 等价于
        struct student stu1, stu2;
        ```



+ <span style="font-size:20px">结构体变量的初始化</span>

    <hr>

    如上例。

    ``` c
    STUDENT stu1 = {2020211785, "Jack", 88};
    STUDENT stu2 = {2020211999, "Max", 99};
    ```

    相当于用结构体模板生成了两个独立的与结构体类型结构一致的变量。



+ <span style="font-size:20px">结构体的嵌套</span>

    <hr>

    嵌套的结构体就是在一个结构体内包含了另一个结构体作为其成员。

    以下是一个例子。

    ``` c
    typedef struct date
    {
        int year;
        int month;
        int day;
    }DATE;
    /* 然后根据这个 DATE 结构体模板声明 STUDENT 结构体模板 */
    typedef struct student
    {
    	long stuID;
        char stuName[10];
        DATE birthday;	// 等同于 struct date birthday
    }STUDENT;
    ```



+ <span style="font-size:20px">结构体变量的引用</span>

    <hr>

    c 语言规定，不能将一个结构体变量作为一个整体进行输入、输出操作，只能对每个具体的成员操作

    访问结构体变量的成员要用**成员选择运算符 / 原点运算符**，访问格式：  
    **结构体变量名.成员名**，如下例。

    ``` c
    stu1.studentID = 2020211785;
    ```

    上面的语句为结构体变量`stu1`的`studentID`成员进行赋值。

    当出现结构体嵌套，

    ``` c
    stu1.birthday.year = 2002;
    ```

    

    c 语言允许对具有相同结构体类型的变量进行整体赋值，赋值后的结果就是两个结构体变量的成员具有相同的内容。

    ``` c
    stu2 = stu1;
    ```

    

## 结构体数组

上文例子中一个结构体变量只能表示一个学生的记录信息，要表示多个具有相同结构的学生记录就要用到结构体数组。



+ <span style="font-size:20px">结构体数组定义</span>

    <hr>

    按照上例声明`STUDENT`结构体类型，然后定义结构体数组如下。

    ``` c
    STUDENT stu[30];
    ```

    上例定义了一个有 30 个元素的结构体数组，每个元素的类型为`STUDENT`。该数组所占内存字节数为`30 x sizeof(STUDENT)`

+ <span style="font-size:20px">结构体数组的初始化</span>

    <hr>

    也可以在定义结构体数组的同时对其初始化，如下例。

    ``` c
    STUDENT stu[30] = {{001, "Jack", {2002, 10, 12}},
                       {002, "Max", {2002, 3, 4}}
                      };
    ```

    上例在定义结构体数组`stu`的同时对数组的前 2 个元素进行了初始化，而其他数组元素被系统自动赋为 0 。这些初值单独成行是为了可读性。



## 结构体指针

### 定义和初始化

结构体指针为指向结构体变量的指针。



假设已经声明了`STUDENT`结构体类型，那么**定义**一个指向该结构类型的指针变量的方法为：

``` c
STUDENT *pt;
```

这时`pt`并没有指向一个确定的存储单元，其值是一随机值，为使其指向确定的存储单元，需要对指针变量进行**初始化**：

``` c
STUDENT *pt;	// 或 struct student *pt;
pt = &stu1;

// 等同于

STUDENT *pt = &stu1;
```



### 访问结构体成员

1. <span style="font-size:20px">箭头运算符</span>

    ``` c
    pt->stuID = 2020211785;
    ```

    

2. <span style="font-size:20px">圆点运算符</span>（不常用）

    ``` c
    (* pt).stuID = 2020211785;
    ```

    因为`()`的优先级比`.`的高，所以先将`(* pt)`作为一个整体，取出`pt`指向的结构体的内容，再将其看成一个结构体变量，利用`.`访问它的成员。

    ``` c
    pt->birthday.year = 2002;
    ```



### 指向结构体数组的指针

``` c
STUDENT *pt = stu;

// 等价于

STUDENT *pt = &stu[0];

// 等价于

STUDENT *pt;
pt = stu;
```



### 向函数传递结构体

将结构体传递给函数的方式有 3 种：

1. 向函数传递结构体的**单个成员**，用**结构体单个成员**作函参

    **传值调用**，与普通类型变量作实参没有区别。不会引起结构体成员值的变化，这种方式很少使用。

    

2. 向函数传递结构体的**完整结构**，用**结构体变量**作函参

    也是**传值调用**。当实参与形参是同一种类型时，才可以使用这种方式传递==？==。这种传递方式更直观，但时、空开销大。

3. 向函数传递**结构体地址**，用**结构体指针**或**结构体数组**作函参

    **传地址调用**，因为值复制结构体首地址给被调函数，因此相对于第 2 种方式效率更高。



## 共用体

共用体是将不同类型数据组织在一起共同占用同一段内存的一种构造数据类型。	==？==

共用体与结构体的类型**声明**方法一致，只是关键字变为`union`

``` c
union sample
{
    short i;
    char ch;
    float f;
};
typeof union sample SAMPLE;
```



共用体与结构体的**区别**：

共用体在每一瞬间起作用的成员是最后一次被赋值的成员。因此不能同时对共用体所有成员初始化。但允许按名设置成员初值。	==?==

``` c
SAMPLE u = {.ch = 'a'};
```



使用场景：采用共同体存储程序中逻辑相关但情形互斥的变量。如，

``` c
union maritalState	// 定义婚姻状况共同体类型
{
    int single;
    struct divorceState divorce;	
    struct marriedState married;
};
struct duvorceState
{
    struct date divorceDay;
    int child;
}
// ...
```



## 枚举数据类型

当某些量仅由有限个数据值组成时，通常用枚举类型表示。枚举数据类型（*Enumerated Data Type*）描述的是一组整型值的集合，需用关键字`enum`来定义。



``` c
enum response{no, yes, none, unsure};
enum response answer;
```

上面的语句 1 **声明**了枚举类型`response`，`{}`内的是可能取值；语句 2 定义了`response`枚举型变量`answer`。

一般情况，第一个**枚举常量**（*本例的 `no`*）**值**为 0，后面的依次递增 1。

上例可用`no`、`yes`、`none`、`unsure`中任一值给变量`answer`**赋值**。如

``` c
answer = no;
```



上例的`respnse`称为**枚举标签**，当枚举类型和枚举标签一起定义时，枚举标签可省略不写。如：

``` c
enum {no, yes}answer;
```



## 动态数据结构 单向链表

使用动态数据结构，是利用动态内存分配、使用结构体并配合指针实现的一种数据结构。



+ <span style="font-size:20px">动态数据结构</span>

    <hr>

    结构体声明时不能包含本结构体类型成员，因为定义尚未结束，所占用内存字节数未确定，系统无法为这样的结构体成员分配内存

    但声明结构体类型时可包含**指向 本结构体类型 的指针成员**，因为地址所占内存字节数确定

    例如：

    ``` c
    struct temp
    {
        int data;
        struct temp *pt;
    };
    ```

    这是动态数据结构的编程基础
    
    

+ <span style="font-size:20px">链表的定义</span>

    链表只能顺序访问，首先找到链表的头指针，即指向第 1 个节点的指针，依次后传直到节点的指针域（*结构体指针，用于存储后继节点信息*）为 NULL，表示到了尾部节点。



==。。。==



# 文件操作

## 文件的打开和关闭

函数**`fopen()`**用来打开文件，其函数原型为：

``` c
FILE *fopen(const char *filename, const char *mode);
```

`fopen()`的**返回值**是一个文件指针；  
第一个形参`filename`表示文件名，可包含路径和文件名两部分；第二个形参`mode`表示文件打开方式，取值如下：

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| r    | 打开一个已有的文本文件，允许读取文件。                       |
| w    | 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 |
| a    | 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 |
| r+   | 打开一个文本文件，允许读写文件。                             |
| w+   | 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 |
| a+   | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 |

如果处理的是二进制文件，则需使用下面的`mode`取值：

"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"



例如：

``` c
fp = fopen("D:\\demo.txt", "a+");
```

注意文件路径表示中的`\\`。



使用完文件后必须关闭文件，否则会出现意想不到的错误。函数`fclose()`用来关闭一个由`fopen()`打开的文件。

``` c
int fclose(FILE *fp);
```

**返回**一个整型数。文件关闭成功时返回 0；否则返回一个非 0 值。



## 按字符读写文件

### 读写文件中的字符

+ <span style="font-size:20px">读</span>

    <hr>

    函数`fgetc()`用于从一个 以只读或读写方式打开的文件上 读字符。其函数原型为：

    ``` c
    int fgetc(FILE *fp);
    ```

    其中，`fp`是由函数`fopen()`返回的文件指针；

    该函数的功能时从`fp`所指的文件中读取一个字符，并将位置指针指向下一个字符。

    若读取成功，返回该字符；读到末尾，返回**`EOF`**（*符号常量，在 `stdio.h` 中定义为 `-1`*）



+ <span style="font-size:20px">写</span>

    <hr>

    函数**`fputc()`**用于将一个字符写到一个文件上。其函数原型为：

    ``` c
    int fputc(int c, FILE *fp);
    ```

    其中，`fp`是由函数`fopen()`返回的文件指针；`c`是要输出的字符。

    该函数的功能是将字符`c`写到文件指针`fp`所指的文件中。

    若写入错误，返回`EOF`；否则返回字符`c`。



<div id = "fof">函数`fof()`用于检查是否到达文件末尾，当文件位置指针指向文件结束符时，返回非 0 值；否则返回 0 。其函数原型为：</div>

``` c
int fof(FILE *fp);
```



### 读写文件中的字符串

+ <span style="font-size:20px">读</span>

    函数**`fgets()`**原型为：

    ``` c
    char *fgets(char *s, int n, FILE *fp);
    ```

    该函数从`fp`所指的文件中读取字符串并在字符串末尾加`\0`，然后存入指针`s`，最多读`n-1`个字符。

    当 读到回车换行符，到达文件尾，或读满`n-1`个字符 时，函数返回该字符串的首地址，即指针`s`的值；读取失败时返回空指针（*`NULL`*）。

    因为 出错和到达文件尾时都返回`NULL`，因此应使用`fof()`或`ferror()`确定函数`fgets()`返回`NULL`的实际原因。

    函数`ferror()`用来检测是否出现文件错误，如果出现错误，返回一个非 0 值；否则，返回 0。

    与`gets()`不同的是，`fgets()`从指定的流 读字符串，读到换行符时将换行符也作为字符串的一部分读出



+ <span style="font-size:20px">写</span>

    函数**`fputs()`**原型为：

    ``` c
    int fputs(const char *s, FILE *fp);
    ```

    若出现写入错误，则返回`EOF`；否则，返回一个非负数。

    与`puts()`不同的是，`fputs()`不会在写入文件的字符串末尾加上**换行符**

 

## 按格式读写文件

+ <span style="font-size:20px">读</span>

    函数**`fscanf()`**用于按指定格式从文件读数据。其函数原型为：

    ``` c
    int fscanf(FILE *fp, const char *format, ...);
    ```

    其中，第一个**参数**为文件指针；第二个参数为格式控制参数==？==；第三个参数为地址参数表列==？==。后两个 参数和返回值 与函数`scanf()`相同。==？==



+ <span style="font-size:20px">写</span>

    函数**`fprintf()`**用于按指定格式向文件写数据。其函数原型为：

    ``` c
    int fprintf(FILE *fp, coonst char *format, ...);
    ```

    其中，第一个**参数**为文件指针；第二个参数为格式控制参数==？==；第三个参数为输出参数表列==？==。后两个参数和返回值 与函数`printf()`相同。==？==



**优缺点**：用函数`fscanf()`和`fprintf()`进行文件的格式化读写，方便、容易理解；但输入时要将**ASCII** 字符转换成**二进制**数，输出时要将二进制数转换成 ASCII 字符，耗时较多。	==？==



## 函数

`fopen(<>, <>)`

`fseek(<文件指针>, <偏移量>, )`	==?==

`ftell(<文件指针>)`：判断文件是否为空

`rewind(<文件指针>)`

`feof()`：用于判断是否读到了文件结尾，是返回 1

`fread(<buffer>, <size>, <count>, <stream>)`：`buffer`为接收数据地址，`size`为一单元大小，`count`为单元个数，`steam`为文件流。返回值为实际读取的单元个数

`fwirte(ptr, size, numemb, stream)`：`ptr`要写入的数组的指针，`size`：要写入的每个元素字节，`nummb`元素个数，`stream`文件指针



























 

