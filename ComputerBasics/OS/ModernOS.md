# 现代操作系统



# 概述

> **复习大纲：**
>
> 1. 操作系统的基本概念、基本功能；
>2. 分时系统、批处理系统、实时系统的主要特征；
> 3. 用户接口、系统调用过程
>4. 单道与多道程序技术；
> 5. 操作系统虚拟机体系结构
>6. CPU工作模式；



## 操作系统

> 操作系统的基本概念、基本功能

**功能：**

+ 资源管理者
  +  处理机管理 
  +  内存管理
  +  设备管理
  +  文件管理 
+ 扩展机器
  + 用户接口

<span style="color:blue;font-weight:bold">两个主要功能：</span>

+ 资源管理者——有效管理计算机软硬件资源
+ 作为扩展机器——为用户提供比实际机器更便于运用的抽象，包括进程、地址空间、文件等，提供接口

**主要功能：**处理机管理，内存管理，设备管理，文件管理，用户接口

**特征：**并发性，共享性，虚拟性，异步性

**两个基本特征**：并发性，共享性



## 系统分类

> 分时系统、批处理系统、实时系统 的主要特征

**批处理系统：**

+ 多道性、并发性、无序性、调度性

+ 无交互能力、作业平均周转周期长

**分时系统：**（N 个用户，时间片轮转，更强调人机交互）

+ 多路性、交互性、独占性、及时性

**实时系统**

+ 对控制对象作出及时反应，资源利用率低



## 单道与多道程序技术

> 单道与多道程序技术

**多道程序设计：**

+ <span style="color:blue">概念</span>：CPU在内存中多个进程之间迅速切换，使得多道程序能并发执行
+ 多道程序设计技术是**现代操作系统诞生的标志**

<span style="color:blue;font-weight:bold">分时系统和多道程序系统的区别：</span>

+ 分时系统运行多个用户使用自己的终端 同时 执行计算系统上的计算；多道程序系统允许用户同时运行多个程序
+ 所有分时系统都是多道程序设计系统；并非所有多道都是分时系统。因为多道可以在只一个用户的 PC 上运行



## 操作系统的硬件系统

### CPU

> CPU 工作模式

**CPU 两种工作模式：**用户态（仅允许执行部分指令和功能），内核态

+ 特权指令只能在内核态下执行
+ 因此用户程序必须通过 <span style="color:orange">系统调用</span> 陷入内核调用 OS 相关服务
+ <span style="color:blue">内核态和用户态的区别：</span> 内核态 CPU 可执行指令集中每条指令，可使用硬件所有功能；用户态只能部分



## 用户接口

> 用户接口、系统调用过程

**用户接口类型：**

+ 图形用户接口——图形化操作界面
+ 系统调用（程序接口）——用户程序用该接口访问系统资源，获取操作系统服务（库函数）
+ 命令接口（联机命令）——提供给用户以命令方式使用系统（Shell 语言）

**系统调用过程：**

1. Trap 指令，切换至内核态

<span style="color:blue;font-weight:bold">系统调用目的：</span> 请求系统服务



## 体系结构

> 操作系统虚拟机体系结构



# 进程与线程

> **复习大纲：**
>
> 1. 进程的基本概念、并发与并行；
>
> 2. 线程的基本概念
>
> 3. 进程与程序、进程与线程的区别与联系
>
> 4. 进程的实现（PCB）、线程的实现（TCB）；
>
> 5. 进程的状态及其转换；
>
> 6. 进程控制原语
>
> 7. 临界资源、临界区概念；
>
> 8. 进程通信的方式；
>
> 9. 进程的同步与互斥信号量实现；
>
> 10. 调度目标与常用的作业及进程调度算法；

**关系：**

一个进程可有多个线程

线程可并发执行

线程是调度的独立单位，资源分配给进程，同一进程所有线程共享该资源



## 进程

> 1. 进程的基本概念、并发与并行
>
> 2. 进程的状态及其转换
>
> 3. 进程控制原语

**进程：** **资源分配**的基本单位

**并发与并行：**

都是 CPU 执行多个任务的方式

并发：只有一个 CPU，在同一时间点，任务并不会同时运行，只是用**时间片轮转实现了宏观上**一个时间段内多个任务同时运行的效果

- 有竞争关系

并行：同一时刻多个任务同时执行。多个 CPU 实现

- 无竞争关系



### 进程的状态及转换

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Process_states.svg/400px-Process_states.svg.png" alt="img" style="zoom:93%;" />

+ 就绪 **waiting**——等待调度；运行 **running**；阻塞 **blocked**——等待资源

  waiting——可运行，但因为其他进程正在运行而暂时停止

  runnning——占用 CPU

  blocked——除非某种外部事件发生，否则进程不能运行

<span style="color:blue;font-weight:bold">状态转换</span>



### 进程控制原语

进程创建 `create()`

进程终止 `exit()`

进程阻塞 `block()`

进程唤醒 `wakeup()`



## 线程

> 线程的基本概念

**概念：**进程的一个执行单元，是**独立调度**的基本单位



## 进程与程序, 进程与线程

> 进程与程序、进程与线程 的区别与联系

<span style="font-size:20px">进程与程序</span>

联系：一个程序生成多个进程

区别：程序不具备 动态，并发，独立，异步，结构



<span style="font-size:20px">进程与线程</span>

联系：线程依赖于进程，进程中使用多线程并行处理提高效率

区别：

- 系统开销：系统创建、撤销进程的开销远大于对线程的开销
- 通信：同一进程的线程间可直接读写；进程间通信需借助 IPC（进程间通信）



## 进程 / 线程 的实现

>  进程的实现（PCB 进程控制块）、线程的实现（TCB 线程控制块）

<span style="font-size:20px">进程的实体</span>

+ **进程的内存空间：**

  - 数据段——进程的全局变量和静态变量

  - 代码段

  - 堆栈段——栈存储函数调用信息；堆存储动态分配的内存
+ 进程表表项（进程控制块 **PCB**）
+ 正在执行的进程和 CPU 现场



<span style="font-size:20px">PCB 的实现</span>（Process Control Block）

**PCB 字段：**

+ 进程管理
+ 存储管理
+ 文件管理

**PCB 组织方式：**（组织多个 PCB）

+ 链接组织方式
+ 索引组织方式



<span style="font-size:20px">线程的实现：</span>

+ 用户空间中实现
+ 内核中实现
+ 混合实现

<span style="color:blue;font-weight:bold">用户态实现线程的优缺点：</span>

优点：

1. 调度速度快
2. 内核对线程包一无所知，可在不支持多线程的操作系统实现多线程编程
3. 允许每个进程有自己的调度算法
4. 较好可扩展性，因无需内核空间支持

缺点：

1. 实现阻塞系统调用困难
2. 效率低——缺页问题
3. 易出现线程永久运行问题
4. 对 CPU 繁忙型应用不利



## 临界资源、临界区

> 临界资源、临界区概念

**临界资源：**一次只允许一个进程使用的 软硬件资源

**临界区：**在每个进程中，访问临界资源（共享内存）的那部分代码（那段程序）



## 进程间通信

> 1. 进程通信的方式
>
> 2. 进程的同步与互斥信号量实现

<span style="font-size:20px">基本概念</span>

**制约关系：**

+ 进程互斥（间接相互制约）：进程竞争共享——另一必须等待
+ 进程同步（直接相互制约）：进程间合作——相互协调

**中断：**响应硬件设备请求的一种机制



<span style="font-size:20px">解决进程互斥:</span>

+ **屏蔽中断：**进程进入临界区后先关中 断，离开前开中断

+ **加锁法：**锁变量来表示临界区是否可用

+ **严格轮换法**
+ **Peterson 解决方案**
+ **TSL 指令**

 

### IPC

Inter Process Communication——进程通信

<span style="font-size:20px; color:red">信号量 - Semaphore</span>

值仅由 `down` / P, `up` / V **原语改变**

**物理意义：**s >= 0: 可使用资源数；s < = 等待使用资源的进程数

`P(S)` 申请一个资源；`V(S)` 释放一个资源

**复杂情况：** 一个同步 P 操作与一个互斥 P 操作在一起时,同步 P 在互斥 P 前



<span style="font-size:20px">管程 - Monitor</span>

**概念：**更高级的同步原语，进入管程的互斥由编译器负责，使用者只需将临界区转换为管程

**特性：**任一时刻管程中只能有一个活跃进程



<span style="font-size:20px">消息传递 - Message Passing：</span>

**实现：**两个原语 `send`, `receive`

...



## 处理机调度

> 调度目标与常用的作业及进程调度算法

**调度目标：**

+ 低级调度 / 处理机调度（进程调度）
+ 中级调度 / 内存调度
+ 高级调度 / 作业调度



### 实时系统调度

<span style="color:blue;font-weight:bold">判断某实时系统是否可调度:</span>

$\sum^n \frac{C~i}{P~i} <= n(2^\frac{1}{n}-1)$ （n 个周期性任务；C~i~ 处理时间；P~i~ 周期时间）



### 进程调度

**性能评价指标：**

+ 平均周转时间 T: 每一任务完成 - 提交时间 之和 $\frac{1}{n} \sum{T_i}$

+ 平均带权周转时间 T' : $\frac{1}{n} \sum{\frac{T_i}{t_i}}$ （$t_i$ 为实际运行时间）

+ 平均等待时间 W : $\frac{1}{n} \sum{W_i}$



<span style="font-size:20px;color:red">调度算法</span>

**先来先服务 FCFS**

**最短作业优先 SJF**

**轮转调度 RR：**时间片 q

**优先级调度** （优先级高）

**多级队列调度**



# 死锁

> **考试大纲：**
>
> 1. 死锁的概念
> 2. 死锁产生的原因及必要条件
> 3. 死锁问题的四个解决策略
> 4. 安全状态的定义、银行家算法



## 概念

> 死锁的概念

**死锁：**一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件

**不可抢占资源：**从拥有它的进程中抢占将引起相关计算的失败



## 产生原因 ，必要条件

> 死锁产生的原因及必要条件

**形成死锁**四个**必要条件：**

1. 互斥
2. 占有和等待
3. 不可抢占资源
4. 环路等待：存在一条环路，该环路中的每一个进程都在等待下一个进程所占有的资源



## 解决策略

> 死锁问题的四个解决策略
>
> 安全状态的定义、银行家算法

**鸵鸟算法：**（忽略死锁）

**解除死锁：**

1. 死锁检测
2. 死锁恢复
   + 抢占
   + 回滚
   + 杀死进程

**死锁避免：**动态分配资源时防止系统进入不安全状态

+ 银行家算法：进程预先告知自己的最大资源需求

**防止死锁：**破坏必要条件防止产生



### 死锁检测算法

<span style="font-size:18px">每种类型一个资源</span> 的死锁检测 —— 检测有向图是否存在环

<img src="https://camo.githubusercontent.com/5663be4d3b58da1b738412ca4854b61d255974230c1c88875f96511618a5bae0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62316661303435332d613462302d346561652d613335322d3438616363613866666637342e706e67" alt="img" style="zoom: 80%;" />



<span style="color:blue;font-size:20px">每种类型多个资源的死锁检测</span>

**所需数据结构：**

总资源向量 $\vec{E}$（$=\vec{A}+\vec{C}$）；可用资源向量 $\vec{A}$；分配给进程的资源数量 $\vec{C}$；进程请求数量 $\vec{R}$

**算法过程：** 

1. 寻找一没被标记进程 $P~i$，满足请求的资源 $<=\vec{A}$
2.  找到：$A~i~ += C~i$，标记该进程 （执行 $P~i~$，释放所占资源 $C~i~$）
3. 没找到：算法终止 —— 没被标记的进程都是死锁进程



### 死锁避免 - 安全状态，银行家算法

**安全状态：**现有的资源占有情况下，按照某推进顺序仍可使每个进程得到其对资源的最大需求



<span style="color:red">**银行家算法**</span>

<span style="font-size:20px;color:blue">多个资源的银行家算法</span>

已分配资源 - 最大需求量 - 可用资源



# 存储管理

> **考试大纲：**
>
> 1. 分页存储管理方式原理及地址映射过程
> 2. 虚拟存储技术（覆盖、交换）
>
> 3. 物理内存管理方式（位图、空闲链表）
>
> 4. 页表组成、TLB、页的大小
>
> 5. 常用页面置换算法及缺页率计算（FIFO，LRU，时钟页面置换算法）
>
> 6. 段式与页式存储管理方式的主要区别



## 分页存储管理方式, 地址映射

> 分页存储管理方式原理及地址映射过程



<span style="font-size:20px">地址映射</span>（重定位）

从逻辑地址到物理地址的地址映射



## 地址空间

> 物理内存管理方式（位图、空闲链表）

**地址空间:** 一个进程可用于寻址内存的一套地址集合——一种存储器抽象

<span style="font-size:20px">位图</span>

内存划分成一定大小的分配单元，每 个单元对应位图中的一位



<span style="font-size:20px;color:blue">链表——内存分配算法</span>

为创建的进程分配内存

**首次适配算法 First Fit: **沿链表搜索找到足够大空闲区

**下次适配算法 Next Fit:**  对首次适配算法调整，记录搜索停止位置，下次从此开始

**Best Fit:** 搜索整个链表，找到满足的最小空闲区

**Worst Fit:** 能容纳的最大空闲区

**Quick Fit: **为常用大小空闲区维护单独的链表

 

## 虚拟存储技术

> 虚拟存储技术（覆盖、交换）

**内存超载 解决方案：**

+ 交换——进程完整 调入内存，使该进程运行一段时间，然后把 它调回磁盘
+ 覆盖——程序按逻辑覆盖
+ 虚拟内存



<span style="font-size:20px">虚拟内存</span>

处理内存超载的重要技术

基本思想：每个进程拥有自己的地址空间，分割成多个大小相等的块，每一块称作页。让部分页进驻内存也能顺利执行

技术基础：离散内存分配。进程的<span style="color:orange">逻辑地址空间分散存储</span>在内存不连续的<span style="color:orange">物理地址空间</span>



## 页
## 物理内存管理方式

> 物理内存管理方式（位图、空闲链表）

<span style="font-size:20px">位图</span>

内存划分成一定大小的分配单元，每 个单元对应位图中的一位

​                 

<span style="font-size:20px">空闲链表</span>



## 虚拟内存

> 1. 分页存储管理方式原理及地址映射过程
> 2. 页表组成、TLB、页的大小
> 3. 常用页面置换算法及缺页率计算（FIFO，LRU，时钟页面置换算法）
> 4. 段式与页式存储管理方式的主要区别
>

### 分页

<span style="font-size:20px">有关概念</span>

**页框:** 将内存空间分成各个大小相等分区

**页（页面）:** 将用户进程的地址空间分为各个与页框大小相等区域

**页表项:** 由页表项找到页框号。由页号和物理块号组成

R（访问）位；M（修改）位



<span style="font-size:20px;color:blue">地址变换</span>

**逻辑地址格式:** 页号 | 页内偏移量

> **页号 / 页内偏移量 各占几位地址:**
>
> 页号: 页式存储系统共 $x$ 页，则需 $log_2x$ 位
>
> 页内偏移量: 每页大小

逻辑地址 $\div$ 页面大小 = 页号 mod 页内地址

**物理地址:** 页号对应的物理块号 * 页面大小 + 业内地址



<span style="font-size:20px">页表</span>

**页表** 给出 虚拟地址 与 物理地址 之间 的映射关系——虚拟地址分成虚拟页号和偏移量

**MMU：** 内存管理单元，完成地址映射。

+ CPU 发送 虚拟地址 给 MMU
+ MMU 发送 物理地址 给 存储器



<span style="color:blue;font-weight:bold">计算 页面大小 && 页面个数:</span>

> D: 一个 32 位地址的计算机使用两级页表。虚拟地址被分为 9 位的顶级页表域、11 位的二级页表域和一个偏移量，页面大小是多少
>
> **页面大小:** （虚拟地址分配）
>
> 1. $9 + 11 = 20$ 位用于虚页号
> 2. 偏移量 = $32-20=12$
> 3. 页面大小 $2^{12}=4KB$
>
> **页面个数：** 
>
> 20 位虚页号，所以 $2^{20}$ 页



<span style="font-size:20px">TLB</span>

用于**加速分页**，存储少量 页表项 的相关信息

**TLB：**Translation Lookaside buffer 转换检测缓冲区。通常在 MMU 中



==?==

> Q: 从平均寻道时间10ms、旋转延迟时间10ms、每磁道32KB的磁盘上载入一个64KB的程序，对于下列页面大小分别需要多少时间？
> （a）页面大小为2KB；（b）页面大小为4KB
> 假设页面随机分布在磁盘上，柱面的数目非常大，以至于两个页面在同一个柱面的概率可以忽略不计。



### 页面置换算法

**场景：**

1. 访问页不在内存，引起**缺页中断**
2. 无空闲页框
3. **页面置换** 选择一个页面换出，为即将调入内存的页面腾出空间

<span style="color:blue;font-weight">使用相应算法的缺页中断次数:</span> 访问的页面不在当前几个页框中 的次数



<span style="font-size:20px">NRU</span> ——最近未使用页面置换算法

需要参考 (访问位 R, 修改位 M)，淘汰一个编号最小页面

> 0: 未被访问, 未被修改（00）...

<span style="font-size:20px">FIFO</span> ——先进先出页面置换算法

OS 维护一个 所有当前在内存中页面 的 <span style="color:orange">链表</span>

在 表头 的最久进入页 被置换出内存

<span style="font-size:20px">SCR</span> ——第二次机会

对 FIFO 的修改，置换时检查访问位 R：

+ R 为 0，置换
+ R 为 1，置 0 插入表尾

<span style="font-size:20px">LRU</span> ——最近最少使用页面置换算法

<span style="color:orange">链表</span> ，使用最多在表头

<span style="font-size:20px">Clock</span>——时钟页面置换算法

<span style="color:orange">环形链表</span>，表针指向最老页面

置换时检查表头页面的访问位 R



### 段式与页式 区别

+ 页是信息的<span style="color:orange">物理单位</span>，段是信息的<span style="color:orange">**逻辑单位**</span>， 分页是系统管理的需要，分段是用户的需要

+ 页大小固定；段**大小动态变化**
+ 分段系统 **二维逻辑地址空间**；分页系统一维
+ 分段易实现 **共享和动态链接**



# 文件系统

> **考试大纲：**
>
> 1. 文件的逻辑结构、物理结构
>
> 2. 文件FCB、文件目录及实现、目录文件
>
> 3. 文件的共享方式
>
> 4. 文件系统的可靠性
>
> 5. 文件系统的性能
>
> 6. ==?== 的磁盘空间管理成组链接法

## 文件结构

> 文件的逻辑结构、物理结构

<span style="font-size:20px">逻辑结构</span>

+ 字节序列
+ 记录序列（顺序结构）
+ 树



## 目录

> 文件 FCB、文件目录及实现、目录文件

<span style="font-size:20px">FCB</span>

FCB（**文件控制块**）——目录项，目录的基本组成元素

**内容：**管理文件所需有关信息——文件名，存储地址，存取控制信息，使用信息 等



<span style="font-size:20px">目录</span>

FCB 的有序集合

**实现：**访问文件时，

1. OS 利用用户提供的<span style="color:orange">路径名</span>找到该文件的 <span style="color:orange">FCB</span>
2. 根据<span style="color:orange">FCB</span> 的信息<span style="color:orange">访问文件</span>



<span style="font-size:20px">目录文件</span>

**目的：**为了实现对文件目录的管理

**概念：** 将文件目录<span style="color:orange">以文件的形式保存在外存</span>，这个文件就叫目录文件



<span style="color:blue;font-weight:bold">查找一个文件平均启动磁盘次数:</span>

> Q: 某文件系统中，一个 FCB 占用 64B，盘块大小 1KB，文件目录中共 3200 个 FCB，则查找一个文件平均启动磁盘次数为 (100)
>
> A: 
>
> 1. 3200 个 FCB 所需占用盘块数: $\frac{3200}{\frac{1KB}{64B}}=200$
> 2. 盘块均匀分布在磁盘上，==为找到目标文件需访问一半盘块?== $200\div2=100$ 个 



## 共享文件

> 文件的共享方式

<span style="font-size:20px">硬链接</span>

<span style="font-size:20px">符号链接</span>

**本质** 通过 LINK 类型文件路径名指向共享文件

**特点** 额外 存储和查找 开销大




## 文件系统可靠性
> 文件系统的可靠性

**保障可靠性措施:**

1. 文件系统备份
2. 文件系统一致性检查



<span style="font-size:20px">文件系统备份</span>

自动进行（转储程序和恢复程序）

**转储策略：** 全量 / 增量

**转储方案：**物理转储 / 逻辑转储

+ 物理：全部磁盘盘块按序输出到备份磁带（全量）
+ 逻辑：递归转储基准日期后更改的文件（增量）

**逻辑转储 算法过程：**

> <img src="https://camo.githubusercontent.com/b5b4ece6b83333d0b3d5baa50d134e67efa44212bc4dcfb9451a2158721e3ea0/68747470733a2f2f696d67323032302e636e626c6f67732e636f6d2f626c6f672f313531353131312f3230323030332f313531353131312d32303230303332353133313531323933312d323035313039363031302e706e67" alt="img" style="zoom:33%;" />
>
> <img src="https://camo.githubusercontent.com/05673a38404314866fda86c5fde86717f6881ec65476b76a3209df63d15f0887/68747470733a2f2f696d67323032302e636e626c6f67732e636f6d2f626c6f672f313531353131312f3230323030332f313531353131312d32303230303332353133313532313033372d3938363232383237372e706e67" alt="img" style="zoom:33%;" />

0. 维持一个以节点号为索引的**位图**
1. 递归检查所有目录项，<span style="color:orange">标记修改过的节点（文件和目录）</span>
2. 删除目录树中 不含修改过文件/目录 的目录 的标记
3. 转储位图中所有已标记目录
4. 储位图中所有已标记文件

**文件系统恢复：**

1. 在磁盘创建一空文件系统
2. 恢复最近完整转储
3. 恢复增量存储



<span style="font-size:20px">文件系统一致性</span>

**问题：**盘块修改后由于系统崩溃没有全部写回会导致不一致

**盘块的一致性检查：**

1. 构造两张为每个盘块设立一个计数器的表。一张记录盘块在文件中出现次数，另一记录在空闲表出现次数

+ 一致的状态（每个块号在两张表只出现一次 1 - 0 / 0 - 1）：

<img src="https://camo.githubusercontent.com/e38622a299193ef6d7939df5dd3a8586a1591d695c9aad1b7f628ec44c69beb4/68747470733a2f2f696d67323032302e636e626c6f67732e636f6d2f626c6f672f313531353131312f3230323030332f313531353131312d32303230303332353133313630373031332d3835363637353937382e706e67" alt="img" style="zoom: 33%;" />

+ 某块号丢失 （0 - 0）：添加到空闲表
+ 在空闲表重复（0 - 2）：
  + 解决：修改空闲表
  + 注意：位图法记录空闲盘块，则不会出现该状态
+ 在两文件重复（2 - 0）：
  1. 分配一空闲块
  2. 复制 i 号块内容到空闲块
  3. 用 i 号块替换某文件中 i 号块
  4. 报告用户检查文件内容

**文件一致性**：

构造一张表，计数器，记录文件在目录系统出现次数

注意：

+ 硬连接引起的文件共享使得文件 可能出现在多个目录中
+ 但 符号链接的共享 不会计数



## 文件系统性能

> 文件系统的性能

访问磁盘速度远远慢于访问内存

 **改善性能的常见三种措施：**高速缓存、块提前读、减少磁臂运动



<span style="font-size:21px">高速缓存</span>

**本质：**逻辑上磁盘，物理上在内存

**注意：**区分于虚拟内存

**思想：**把磁盘上若干块保存在高速缓存，访问时先在高速缓存查找再访问物理磁盘

**技术点：**

+ 页面置换算法——实现高速缓存中盘块的置换
+ 高速缓存中快速查找块——根据盘块地址建立散列表



<span style="font-size:21px">块提前读</span>

在需要使用块之前写入高速缓存（提高命中率）

**特点：**只适用于顺序读取



<span style="font-size:21px">减少磁臂运动</span>

**思想：**把有可能顺序访问的块放在一起，最好是在同一柱面上从而减少磁盘臂的移动次数



# 输入/输出 管理

> **复习提纲：**
>
> 1. 常用 I/O 数据传送方式
> 2. I/O 独立编址与统一编址
> 3. Spooling 系统
> 4. I/O 软件的分层结构及其功能
> 5. 磁盘设备读写时间构成
> 6. 常用磁盘臂调度算法

## I/O 传输方式

> 常用 I/O 数据传送方式

**四大方式：** 

+ 程序控制 I/O 方式、中断驱动 I/O 方式、DMA 控制 I/O 方式、通道控制 I/O 方式
+ CPU 与 I/O 设备<span style="color:orange">并行度</span>递增；<span style="color:orange">单次控制传输量</span>递增；<span style="color:orange">设备速度</span>递增

<span style="font-size:21px">程序控制 I/O</span>

**过程：**

1. CPU 向 控制器 发指令，启动 I/O 设备
2. 同时，状态寄存器中状态标志 置 1（busy = 1）
3. 循环检测 busy 标志

**缺点：**字节为数据交换单位，CPU 忙等待 I/O



<span style="font-size:21px">中断驱动 I/O</span>

**过程：**

1. CPU 发出 I/O 命令
2. CPU 执行其它进程，与外设 <span style="color:orange">并行工作</span>
3. I/O 完成操作，控制器向 CPU 发送中断信号，CPU 应答中断
4. 原进程继续运行

**缺点：**字节为数据交换单位。设备较多时，中断次数会很多，CPU 计算时间减少



<span style="font-size:21px">DMA 控制 I/O 方式</span>

**DMA——直接内存访问：**意味着 CPU 授予 I/O 模块权限在不涉及 CPU 的情况下读取或写入内存，减少 CPU 对 I/O 操作干预

**DMA 控制器组成：**

+ 控制 / 状态 寄存器 CR
+ 内存地址寄存器 MAR
+ 数据寄存器 DR
+ 数据计数器 DC



<span style="font-size:21px">通道控制 I/O 方式</span>

**引入：** 

1. 进一步减少 CPU 的干预
2. 多个块为单位传送
3. 一次传送多组数据到多个内存区域



## IO 端口编址方式

> I/O 独立编址与统一编址

外设通过读写设备上的寄存器来进行，外设寄存器也称为 **I/O 端口**

<span style="font-size:21px">统一编址</span>

主存的一部分划出来用作 IO 地址空间，每个端口占用一个存储单元的地址



<span style="font-size:21px">独立编址</span>

IO 地址与存储地址分开独立编址，I/O 端口地址不占用存储空间的地址范围

通过 MEMR/MEMW 和 IOR/IOW 两组控制信号来实现对 I/O 端口和存储器的<span style="color:orange">不同寻址</span>



## I/O 软件层次

> I/O 软件的分层结构及其功能

各层结构和功能：

1. 用户级软件
2. 设备独立性软件
3. 设备驱动程序
4. 中断处理程序

<img src="https://camo.githubusercontent.com/49f85a56fa6993e60d5b2569e4c9ba6bad4c973c9db31ebef7fd6518df1f8f49/68747470733a2f2f696d67323032302e636e626c6f67732e636f6d2f626c6f672f313531353131312f3230323030362f313531353131312d32303230303631383130353734363432302d313330313038363131332e706e67" alt="img" style="zoom:33%;" />



### 用户级软件

> Spooling 系统

**层次：** 用户空间的 I/O 软件

**假<span style="color: orange">脱机</span>系统** SPOOLing, Simultaneous Peripheral Operation On Line

**意义：**专门利用 SPOOLing 程序完成对设备的 IO 操作，无需使用外围 I/O 处理机（真脱机系统）

> **假脱机和真脱机:** （两种不同的输入输出方式
>
> 假脱机：IO 设备无真正独立控制权，IO 操作由主机操作系统协调完成，
>
> 真脱机：IO 设备具完全独立控制权，IO 操作可由设备本身完成

**假脱机作用:**

<span style="color:blue">为什么打印机的输出文件在打印前通常都假脱机输出在磁盘上:</span>

> 不将输出直接分配给打印机的原因：
>
> 1. 打印输出需通过 IO，阻塞进程
> 2. 打印机与 CPU 处理能力差异大
>
> 通常进程只需将文件输出到磁盘，由打印机管理程序完成后续打印输出



## 盘

> 1. 磁盘设备读写时间构成
> 2. 常用磁盘臂调度算法

### 盘的硬件

<span style="font-size:20px">基本概念</span>

**扇区，磁道，柱面:**

磁道——磁盘表面的圆形轨迹

扇区——磁盘上划分的区域，由磁盘上每个磁道等分成若干弧段

柱面——一组盘片中相同编号磁道形成的圆柱

**磁头，磁臂:**

磁头——每个盘面都有自己的磁头（盘面数==磁头数）

**转速，传输速度: ** 

单位：rpm (转每分)

**旋转时间，寻道时间，传输时间:**

寻道时间——磁头移动到数据所在磁道 所需时间

旋转时间——盘片旋转将请求数据所在扇区移至磁头下方 所需时间

**磁盘容量:** 磁头数 * 磁道数 * 扇区数 * 扇区字节数



<span style="font-size:20px">RAID</span>

**廉价磁盘冗余阵列**，简称 磁盘阵列

利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组



### 磁盘设备读写时间构成

+ **寻道时间：**占主导地位，由磁臂移动速度和磁臂调度算法决定 
+ **旋转延迟时间：**由转速和盘块位置决定 
+ **数据传输时间：**由转速和数据传输量决定



### 磁臂调度算法

磁盘驱动程序响应进程的磁盘请求

<span style="font-size:20px">FCFS</span> 先来先服务



<span style="font-size:20px">SSF</span> 最短寻道优先

选择从当前磁头位置出发，移动最少的磁盘 IO 请求

可能有饥饿状态



<span style="font-size:20px">SCAN</span> 电梯算法

选择当前磁头前进方向上移动最少请求，没有时才改变方向

消除饥饿现象



<span style="font-size:20px">C-SCAN</span> 循环扫描

按固定方向扫描，到达边沿请求直接移动到另一沿第一个请求柱面



# 安全与虚拟化技术

> **复习大纲：**
>
> 1. 系统保护机制：访问控制矩阵、ACL、权能表
> 2. 第一类与第二类虚拟机管理程序



# 简答

> 25'

## 概述

分时系统、批处理系统、实时系统 的特点 <span style="color:blue">18 A</span>



## 进程与线程

进程调度 <span style="color:blue">19 A</span>



## 存储管理

分页 <span style="color:blue">19 A</span>



# 综合

> 35'

## 进程与线程

生产者-消费者问题 <span style="color:blue">19 A</span>



## 死锁

银行家算法 <span style="color:blue">19 A</span>