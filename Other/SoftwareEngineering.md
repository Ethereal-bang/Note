# 软件工程



# 软件工程概述

> 软件的定义
>
> 软件的特点
>
> 软件的分类
>
> 软件危机
>
> 软件工程
>
> 软件生命周期
>
> 软件过程

## 软件的定义

<span style="color:blue">软件危机，诞生了软件工程这个新兴学科</span>



**软件定义:** 软件＝程序 + 数据 ＋文档（文档是与软件开发，维护和使用有关的文字材料）

> 软件是
>
> 能够完成预定功能和性能的可执行的计算机程序
>
> 和使程序正常执行所需要的数据，
>
> 加上描述软件开发过程及其管理、程序的操作和使用的有关文档



## 软件的特点

<span style="color:blue;font-size:20px">软件工程本质特性:</span>

+ 软件工程的中心课题是控制复杂性
+ 软件必须有效地支持它的用户
+ 在软件工程领域中是由具有一种文化背景的人替具有另一种文化背景的人创造产品
+ 软件工程关注于大型程序的构造
+ 软件经常变化
+ 和谐地合作是开发软件的关键



## 软件的分类

**按软件的功能进行划分:**

+ 系统软件
+ 支撑软件 —— 协助用户开发软件的工具软件
+ 应用软件



**按软件工作方式划分:**

+ 实时处理软件
+ 分时软件
+ 交互式软件
+ 批处理软件



## 软件危机

<span style="color:blue">不属于软件危机常见表现的有</span>



## 软件工程

**软件工程三要素:** 工具，方法，过程



**系统的开发方法:** 结构化方法，面向对象方法



## 软件生命周期

**软件生命周期:** <span style="color:red">软件有一个孕育、诞生、成长、成熟、衰亡的生存过程</span>



## 软件过程

**软件过程:** 为了获得高质量软件所需要完成的<span style="color:red">一系列任务的框架</span>，它规定了完成各项任务的<span style="color:red">工作步骤</span>

通常用<span style="color:red">软件生命周期模型</span>来描述



**软件开发模型:**

**瀑布模型:**

适用于<span style="color:red">需求非常明确</span>的情况

**快速原型模型:**

<span style="color:red">基本思想</span>是花费少量代价建立一个<span style="color:red">可运行的系统</span>

适用: 项目需求不明确

**增量模型**

第一个构件为核心功能，之后的构建增量开发 (与整体开发模型的瀑布模型不同，属于非整体开发模型)



# 可行性研究

> 2.1 可行性研究的任务
>
> 2.2 可行性研究过程
>
> 2.3 系统流程图
>
> 2.4 数据流图
>
> 2.5 数据字典
>
> 2.6 成本/效益分析

**主要方面:**

技术可行性, 经济，操作



## 系统流程图

**系统流程图与程序流程图是不同的:**

+ 系统流程图表示系统的操作控制和数据流
+ 程序流程图表示程序中的操作顺序



## 数据流图

 **区分数据流、控制流、信息流:**

+ 数据流：仅反映数据流向 (系统的逻辑模型DFD仅反映数据流向)
+ 信息流：反映物理数据流 (系统流程图反映信息流)
+ 控制流：反映物理过程控制时序 (程序流程图中反映控制流向)



<span style="color:blue">作图</span>



## 数据字典

**数据字典:** 关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合



## 成本/效益分析



# 需求分析

> 3.1 需求分析的任务
>
> 3.2 与用户沟通获取需求的方法
>
> 3.3 分析建模与规格说明
>
> 3.4 实体-联系图
>
> 3.5 数据规范化
>
> 3.6 状态转换图
>
> 3.7 其他图形工具
>
> 3.8 验证软件需求

## 需求分析的任务

**软件需求的组成:**

+ 业务需求——反映组织机构和客户对系统、产品高层次的目标要求
+ 用户需求
+ 系统需求
+ 功能性需求
+ 非功能性需求——产品必须具备的属性或品质
+ 设计约束

<b span style="color:blue">非功能性需求</b>：过程需求；产品需求(可用，可靠，安全)；外部需求



## 实体-联系图 (ER 图)

用来定义数据存储需求的模型



**符号:** 

+ 实体 (矩形框)
+ 联系 (菱形框)
+ 属性 (椭圆/圆角)

![image-20230626193235486](/Users/srf/Library/Application Support/typora-user-images/image-20230626193235486.png)



# 总体设计

> 5 . 1 设计过程
>
> 5 . 2 设计原理
>
> 5 . 3 启发规则
>
> 5 . 4 描绘软件结构的图形工具
>
> 5 . 5 面向数据流的设计方法

## 设计原理

<span style="font-size:22px">模块</span>

**模块化的优点**: 复杂性；开发成本；软件生产率

**模块独立性:** 耦合性-低，内聚性-高

**耦合性:** <span style="color:blue">判断存在哪种耦合</span>

+ 数据耦合——通过数据参数交换输入输出信息
+ 控制耦合——传递的是控制信息 - 对被调用模块内部逻辑的控制 (需知被调用模块内部逻辑)
+ 特征 / 标记 耦合——传递数据结构
+ 公共环境耦合
+ 内容耦合



# 详细设计

> **6 . 1 结构程序设计**
>
> **6 . 2 人机界面设计**
>
> **6 . 3 过程设计的工具**
>
> **6 . 4 面向数据结构的设计方法**
>
> **6 . 5 程序复杂程度的定量度量**

## 过程设计的工具

**程序流程图 (FC):** 又称程序框图。以图形方式说明系统中的控制流

<img src="/Users/srf/Library/Application Support/typora-user-images/image-20230626215324864.png" alt="image-20230626215324864" style="zoom:67%;" />



## 程序复杂程度的定量度量

<span style="font-size:20px">McCabe 方法</span>

McCabe 方法根据程序控制流的复杂程度定量度量程序复杂程度，这样度量出的结果称为<span style="color:red">程序的环形复杂度</span>

**一个程序的环形复杂度取决于**它的程序图 (流图) 包含的判定结点的数量

**程序图:** 简化了的流程图，仅描绘程序的控制流程

**程序流程图与对应的控制流图:**

<img src="/Users/srf/Library/Application Support/typora-user-images/image-20230626220322179.png" alt="image-20230626220322179" style="zoom:57%;" />

**环形复杂度 V(G) 计算方法:** (<span style="color:blue">上图为 4</span>)

+ 区域数 (包括图外区域)
+ 判定结点数 + 1
+ E(边数) -  N(结点数) + 2



# 测试

> 7 . 1 编码
>
>  7.2 软件测试基础
>
>  7.3 单元测试
>
>  7.4 集成测试
>
>  7.5 确认测试
>
>  7.6 白盒测试技术
>
>  7.7 黑盒测试技术
>
>  7.8 调试
>
>  7.9 软件可靠性

## 软件测试基础

**测试用例**：通常指测试数据和预期的输出结果

**测试方法:** 黑盒，白盒

+ 已知产品应该具有的功能，可以通过黑盒测试来检验每个功能是否符合设计要求
+ 已知产品的内部工作过程，可以通过白盒法来检验每种内部操作是否按要求的规定正常进行



## 集成测试

单元测试的下一个阶段，指将通过测试的单元模块组装成系统或子系统，再进行测试



<span style="font-size:21px">回归测试</span>

1. 先采取<span style="color:orange">自顶向下</span>的方式测试被修改的模块及其子模块；
2. 将这一部分视为子系统，再<span style="color:orange">自底向上</span>测试



## 白盒测试技术

<span style="font-size:20px">控制结构测试</span>

**基本路径测试:**

1. 计算程序的环形复杂度
2. 设计可强制执行每条独立路径的测试用例

<span style="color:blue">采用基本路径测试的方法，定义执行路径的基本组合</span>



## 黑盒测试技术

黑盒测试方法根据<span style="color:blue">软件要完成的功能</span>设计测试用例

<span style="font-size:21px">等价类划分法</span>

等价类是指某个输入域的子集合



# 维护



# 面向对象方法学引论

> 9.1 面向对象方法学概述
>
>  9.2 面向对象的概念
>
>  9.3 面向对象建模
>
>  9.4 对象模型
>
>  9.5 动态模型
>
>  9.6 功能模型
>
>  9.7 3种模型之间的关系

## 面向对象方法学概述

**OOSD:** Object-Oriented Software Development，面向对象方法

**面向对象** = 对象 + 类 + 继承 + 通信

**OOSD 由三部分组成:**

1. OOA (Object-Oriented Analysis) 面向对象的分析

2. OOD (Object-Oriented Design) 面向对象的设计

3. OOP (Object-Oriented Program) 面向对象的程序设计



<b style="color:blue">面向对象的主要特征:</b> 唯一性，封装，继承，多态



**面向对象开发过程:**

1. 需求分析
2. 设计
3. 实现
4. 测试

需求分析: 获取需求，建立需求模型

1. 获取领域知识；
2. 定义系统功能（用例图 ）； 
3. 确定合适的类； 
4. 建立类的静态模型（类图 ）； 
5. 描述对象的动态行为（状态图、协作图、时序图、活动图 ）； 
6. 验证 （专家对模型作静态验证）； 
7. 给出基本的用户界面原型（整体结构的原型：主窗口的内容、窗口之间的导航等）。



## 面向对象的概念



## 面向对象建模

**需建立三种模型：**

1. 对象模型
2. 动态模型 ——描述系统控制结构
3. 功能模型



## 对象模型

<SPAN STYLE="font-size:22px">类图</span>

使用统一建模语言 **UML** （Unified Modeling Language）提供的类图来**建立对象模型**

UML 用例图是建立功能模型的有力工具

<b style="color:blue">画出 <> 的类图:</b>



## 功能模型

<span style="font-size:22px;color:blue">用例图</span>



## 总结

**三种形式的模型:**

+ 对象模型。描述系统数据结构—数据结构； ——用类图描述
+  动态模型。描述系统控制结构—执行操作；——用状态图描述 
+ 功能模型。描述系统功能—数值变化； ——用 DFD，用例图描述



# 面向对象分析

> 10.1 面向对象分析的基本过程
>
> 10.2 需求陈述
>
> 10.3 建立对象模型
>
> 10.4 建立动态模型
>
> 10.5 建立功能模型
>
> 10.6 定义服务

## 面向对象分析的基本过程

<span style="color:blue">对象模型最基本、最重要、最核心</span>



## 建立对象模型

类图



# 面向对象设计



# 软件项目管理

> 13.1 估算软件规模
>
> 13.2 工作量估算
>
> 13.3 进度计划
>
> 13.4 人员组织
>
> 13.5 质量保证
>
> 13.6 软件配置管理
>
> 13.7 能力成熟模型

## 进度计划

<span style="font-size:22px">甘特图</span>

制定进度计划的工具



# 卷

> 选择 (30)
> 判断 (10)
> 分析设计 (40) ——画类图，数据流图，动态模型，状态转换图，er图
> 测试题 (12)
> 项目管理 (8) ——人员组织 甘特图，网工图，人员组织，问题规模，项目计划，cmm, cmmi



## 选择判断

### 软件工程概述

**什么是软件危机，什么原因导致了软件危机**

软件危机是计算机软件的开发和维护过程中所遇到的一系列严重的问题，主要包含两方面：

+ 如何开发软件，以满足不断增长，日趋复杂的需求
+ 如何维护数量不断膨胀的软件产品

软件危机产生原因：

(与软件本身特点有关:)

+ 软件的规模越来越大，结构越来越复杂
+ 软件开发的管理困难、无计划性
+ 软件开发费用不断增加

(与软件开发与维护方法不正确有关:)

+ 软件需求不充分
+ 软件开发技术落后
+ 软件开发过程无评测手段



**简述软件工程的三要素及各要素的含义**

1. 工具 ——为软件开发提供自动或半自动的软件支撑环境，建立计算机辅助软件工程(CASE)的软件开发支撑系统
2. 方法 ——为软件开发提供“如何做”的技术
3. 过程 ——综合方法及工具，定义方法使用的顺序和所需要的管理



**对比瀑布模型，原型模型，增量模型和螺旋模型**

1. 瀑布模型 规范，文档驱动; 系统可能不满足客户真正的需求
2. 快速原型 克服了瀑布型的缺点
3. 增量模型 开发早期回报明确，易于维护; 要求开放的软件体系结构
4. 螺旋模型 风险驱动，适用于大型项目开发，风险分析人员需要有经验且经过充分训练



### 生命周期

各阶段基本任务:

1. 定义时期 (系统分析)
   + 问题定义 ——<span style="color:red">要解决的问题是什么</span>
   + 可行性研究 ——<span style="color:red">做不做</span> (用最小的代价在尽可能短的时间内从<span style="color:red">经济、技术、社会因素</span>等方面论证解决方案的可行性
   + 需求分析 ——<span style="color:red">正式的文档准确地</span>记录对目标系统的需求，形成软件需求规格说明书 SRS
2. 开发时期
   + 系统设计
     + 总体设计 ——<span style="color:red">怎么做</span>
     + 详细设计 ——<span style="color:red">具体做法</span>
   + 系统实现
     + 编码和单元测试
     + 综合测试
3. 维护时期



| 阶段     | 使用工具 方法                                        |
| -------- | ---------------------------------------------------- |
| 需求分析 | 数据流图；数据词典；逻辑说明工具(判定树；PDL 伪代码) |
| 总体设计 | 变换分析；事务分析                                   |
| 详细设计 | 程序流程图；盒图；问题分析图；判定树；结构化语言     |



#### 总体设计

**模块化**就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集合起来构成一个整体，可以完成指定的功能满足用户需求 

**模块内聚方式**

<img src="/Users/srf/Library/Application Support/typora-user-images/image-20230629145352174.png" alt="image-20230629145352174" style="zoom:57%;" />



### 面向对象方法

面向对象 = 对象 + 类 + 继承 + 消息

**对象 = 一组属性 +** 它可执行的一组操作

**多态:** 当对象接收到发送给它的消息时 ，根据该对象所属的类动态选用在该类中定义的实现算法



## 分析设计

### 数据流图

<img src="/Users/srf/Library/Application Support/typora-user-images/image-20230629092452839.png" alt="image-20230629092452839" style="zoom:50%;" />

<b style="color:blue">分层 DFD 图:</b>

1. 0层: 确定系统范围

<img src="/Users/srf/Library/Application Support/typora-user-images/image-20230629093900060.png" alt="image-20230629093900060" style="zoom:47%;" />



<span style="font-size:22px">软件结构层次图</span>

1. 根节点为系统名
2. 把处理连接成树形结构

+ 矩形框



### 类图

1. 定义类: (类名 ｜ 属性 ｜ 操作)

2. 属性:

   ```
   visibility attribute-name : type = initial-value {property-string}
   可见性      属性名          : 类型  = 初始值         {性质串}
   ```

   + 可见性: `+` 公有，`-`私有， `#` protected，省略 不确定

3. 操作:

   ```
   visibility operating-name(parameter-list): return-type 
   {property- string}
   可见性 操作名（参数表）：返回类型 {性质串}
   ```

4. 类与类的关系: 关联，聚集，泛化/继承，依赖，细化

   关联: 重数表示方法: `1+` 1 到多个对象，`*` 0 到多个对象

   聚集: 整体-部分 关系，连线到整体类端头用菱形 (<span style="color:blue">课题组, 人</span>)

   泛化/继承: 父类端头空心三角形 ▶️

   依赖: 果独立的模型元素改变了，将影响依赖于它的模型元素

复杂类图示例:

<img src="/Users/srf/Library/Application Support/typora-user-images/image-20230627134108293.png" alt="image-20230627134108293" style="zoom:57%;" />



### E-R 图

**符号:**

+ 实体——矩形
+ 联系——菱形
+ 属性——椭圆 (连在实体 / 联系)

<img src="/Users/srf/Library/Application Support/typora-user-images/image-20230629104042543.png" alt="image-20230629104042543" style="zoom:67%;" />



### 用例图

用例图模型元素: 系统，行为者，用例，用例间关系

用例: 系统的一个功能

用例间关系: 

+ 泛化 (一般 ➡️ 特殊)；
+ 包含 (`-->` `《include》`)；
+ 扩展 (`-->` `《extend》`)

<img src="/Users/srf/Library/Application Support/typora-user-images/image-20230627134613147.png" alt="image-20230627134613147" style="zoom:50%;" />



### 状态转移图

**组成:**

+ 状态 (状态｜ 状态变量｜活动表)
+ 事件：事件名(参数) [守卫条件]／动作表达式

<img src="/Users/srf/Library/Application Support/typora-user-images/image-20230629135702987.png" alt="image-20230629135702987" style="zoom:57%;" />

## 测试

### 白盒测试

控制流图；独立路径组合；测试用例

> ```java
>     public int increase(int y,int type){
> 1.      int x=y;
> 2.      if( type >= 0 ||
> 3.              y > 0 )
> 4.      {
> 5.          if (type == 0)
> 6.              x = y + l;
> 7.          else
> 8.              if (type == 1)
> 9.                  x = y + 2;
> 10.         else
> 11.             X = y +3;
> 12.     }
> 13.     return x;
> }
> ```

1. 试画出该求解问题的控制流图，计算环路复杂度。（4分）
2. 采用基本路径测试的方法，列出独立路径组合（3分）
   + 确保走过每一个节点
   + 每一个路径要包含一段新的路径
   + 总数为环路复杂度
3. 设计一组测试用例输入使得可以覆盖所有的独立路径。(3分)



### 黑盒测试

1. 划分等价类
2. 为有效等价类设计测试用例
3. 为每一个无效等价类至少设计一个测试用例

测试用例（编号：PWD）

| 编号   | 等价类性质 | 用例描述      | 数据输入 | 期望输出         |
| ------ | ---------- | ------------- | -------- | ---------------- |
| PWD_01 | 有效等价类 | 有效输入      | <>       | <>               |
| PWD_02 | 无         | 密码长度小于8 | <>       | 无效密码，提示"" |

