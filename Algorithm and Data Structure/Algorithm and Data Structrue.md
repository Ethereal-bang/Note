# 链表

单链表中插入或删除结点时，仅需修改指针不需移动元素

+ <span style="font-size:20px">节点插入：</span>

    先操作待插节点：

    ![image-20211124201659202](https://gitee.com/ethereal-bang/images/raw/master/20211124201706.png)

    ```c
    s->next = p->next;	// 待插节点指针域指向原节点的指针域
    p->next = s;	// 原节点指针域指向待插节点
    ```

    双向链表同理。



# 栈和队列



# 串

## 数组填充

+ **预先**给数组**扩容**带填充后的大小，然后在**从后向前**进行操作：

    这样有两个好处：不用申请新数组；从后向前填充元素避免了从前先后填充元素那样 每次添加元素都要将添加元素之后的所有元素向后移动的问题。



## KMP

KMP 主要用在字符串匹配

+ **主要思想**：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配

+ **重点：**如何记录已经匹配的文本

    

+ <span style="font-size:20px">什么是前缀表</span>：

    **作用**：前缀表（next 数组）是用来回退的，记录了模式串与主串(*文本串* )不匹配时，模式串应该从哪里开始重新匹配

    例子：

    <img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="gif" style="zoom: 67%;" />

    以上图为例，匹配到模式串第 6 个字符`f`时发现不匹配。暴力匹配的话会从头开始匹配；但使用前缀表会从上次已经匹配的内容开始匹配，找到模式串第 3 个字符`b`开始匹配

    **本质**：记录下标`i`之前（包括`i`）的字符串中有多大长度的**相同前缀后缀**

    

+ <span style="font-size:20px">最长公共前后缀</span>：

    **前缀**：<span style="color:red">不包含</span>最后一个字符的所有以第一个字符开头的连续子串

    **后缀**：<span style="color:red">不包含</span>第一个字符的所有以最后一个字符结尾的连续子串

    **最长公共前后缀**：最大相同前缀后缀的长度，例如`a`的最长相等前后缀 0、`aa`为 1；`aaa`为 2。

    前缀表要求的就是相同前后缀的长度

    

+ <span style="font-size:20px">为什么要用前缀表</span>：

    理解为什么使用前缀表可以得知失配后跳到哪里匹配

    例子：依然以![image-20211022090217300](https://gitee.com/ethereal-bang/images/raw/master/20211022090217.png)

    为例，下标 5 之前的最大公共前后缀为`aa`长度为 2，因此从下标 2 字符`b`开始匹配，因为此时文本串的后缀与模式串的前缀相同

    

+ <span style="font-size:20px">计算前缀表</span>：

    求得的最长相同前后缀的长度就是对应前缀表的元素

    如图：![image-20211022094206178](https://gitee.com/ethereal-bang/images/raw/master/20211022094206.png)

    前缀表对应位置的数字表示的就是：下标`i`之前（包括`i`）的字符串中有多大长度的相同前后缀	==为什么不直接存不包括？==

    失配的位置要看它的前一个字符的前缀表的数值，把下标移动到下标`2`继续匹配

    

+ <span style="font-size:20px">前缀表与 next 数组</span>：

    很多 KMP 算法的实现都是使用 next 数组做回退操作，next 数组与前缀表有什么关系呢

    next 数组可以就是前缀表，但很多实现都是把前缀表统一减一（右移一位，初始位置 -1）之后作 next 数组

    至于为什么这样，并不涉及 KMP 的原理而是具体实现，两者均可。

    

+ <span style="font-size:20px">使用 next 数组匹配</span>：

    以下均已前缀表减一的 next 数组演示。



+ <span style="font-size:20px">构造 next 数组</span>：

    构造 next 数组其实是计算模式串`s`前缀表的过程：

    1. 初始化：

        ```js
        let j = -1;	// 前缀表统一减一
        next[0] = j; 
        ```

        next[i] 表示 i（包括i）之前最长相等的前后缀长度`j`。

    2. 处理前后缀不相同情况：

        

    3. 处理前后缀相同情况

    ==。。。==



### 查找子串

在一个串中查找是否出现另一个串，这是KMP的看家本领



# 数组



# 二叉树

## 理论基础

+ <span style="font-size:20px">存储方式：</span>

    链式存储（指针）、顺序存储（数组）

    如何顺序存储：

    <img src="https://gitee.com/ethereal-bang/images/raw/master/20211106180600.png" alt="image-20211106180600214" style="zoom:40%;" />

    如何遍历：父节点`i`，则左孩子`i * 2 +1`，右孩子`i * 2 + 2`

+ <span style="font-size:20px">遍历方式：</span>

    主要有两种遍历方式：

    + 深度优先遍历（递归法、迭代法）：

        + 前序遍历
        + 中序遍历
        + 后序遍历

        这里的“前”、“中”、“后”指的是二叉树中间节点的遍历顺序，例如：

        <img src="https://gitee.com/ethereal-bang/images/raw/master/20211106180259.png" alt="image-20211106180259744" style="zoom:50%;" />

    + 广度优先遍历，又译作宽度优先搜索（迭代法）

        + 层次遍历
        
            沿着树的宽度遍历树的节点(*横向* )



# 堆

堆是用数组实现（*所以没有使用父/子指针*）的二叉树，根据“堆属性”来排序，“堆属性”决定树中节点位置。



**常用方法**：

+ 构建优先队列
+ 支持堆排序
+ 快速找出一个集合中最值



## 堆属性

堆分为两种：最大堆和最小堆，差别在于节点的排序方式。



最大堆中，父节点值比每个子节点的都大。这就是“堆属性”，且这个属性对堆中每个节点都成立，如：

<img src="https://gitee.com/ethereal-bang/images/raw/master/20211004170658.png" alt="image-20211004170651844" style="zoom:50%;" />

根据这一属性，最大堆总将最大值存放在数的根节点。堆属性非常有用，堆常被作为优先队列使用——可以快速访问到最重要元素

要注意，堆的根节点存放的是最值，但其他节点排序顺序未知



## 堆和普通树的区别



# 回溯算法

## 理论基础

<img src="https://gitee.com/ethereal-bang/images/raw/master/20211203135025.png" alt="image-20211203135018550" style="zoom:50%;" />

回溯法是一种搜索方式，回溯是递归的副产品==？==，只要有递归就会有回溯

回溯的本质是<span style="color:red">穷举</span>——穷举所有可能选出想要的答案；其实是暴力查找并不是什么高效算法

+ **主要解决：**
    + 组合问题——N 个数找符条件的 k 个数的集合
    + 切割——一个字符串有几种符条件的切割方式
    + 子集——有多少符合条件的子集
    + 排列——N 个数按一定规则全排列有几种方式
    + 棋盘——N 皇后、解数独...

+ **理解回溯：**

    所有回溯法解决的问题都可抽象为树形结构

    因为回溯解决的都是<span style="color:red">在集合中递归查找子集</span>，集合的大小构成树的宽度，递归的深度构成树的深度

+ <span style="font-size:22px">回溯法模板：</span>

    1. 回溯函数模板——**返回值、参数：**

        习惯函数名取为`backtracking`；返回值一般 void；参数不容易一次性确定，一般先写逻辑、需要什么参数填什么参数

        `void backtracing(<参数>)`

    2. 回溯函数**终止条件：**

        树中可以看出，一般来说搜到<span style="color:red">叶子叶节点</span>就结束本层递归==？==

        ```javascript
        if (<终止条件>) {
        	// 存放结果
        	return;
        }
        ```

    3. 回溯搜索的**遍历过程**：

        <img src="https://img-blog.csdnimg.cn/20210130173631174.png" height="250px">

        ```javascript
        for (/* 选择：本层集合中元素——树中节点孩子的数量就是集合的大小==？== */) {
          // 处理节点
          backtracing(/* 路径， 选择列表 */);
          // 回溯，撤销处理结果==？==
        }
        ```

        for 循环就是遍历集合区间，可理解成一个节点有多少个孩子 这个 for 循环就执行多少次。

        由图可以看出 for 循环可以理解是<span style="color:red">横向遍历</span>，递归 (backtracing) 就是<span style="color:red">纵向遍历</span>，这样就把这棵树全部遍历。

    4. 综上，回溯算法模板框架：

        ```java
        void backtracing(<参数>) {
          if (终止条件) {
            // 存放结果;
            return;
          }
          for (/* 选择：本层集合中元素——树中节点孩子的数量就是集合的大小==？== */) {
          // 处理节点
          backtracing(/* 路径， 选择列表 */);
          // 回溯，撤销处理结果==？==
        	}
        }
        ```

## 子集问题

[力扣](https://leetcode-cn.com/problems/subsets/)——给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集。

求子集问题不同于组合问题、分割问题，组合、分割相当于收集树的叶子节点，子集问题是找树的所有节点

+ **分析：**

    <img src="https://img-blog.csdnimg.cn/202011232041348.png">

+ <span style="font-size:22px">解题步骤：</span>

    1. 递归函数参数：

        全局变量数组`path`为子集收集元素==？==，二维数组`result`存放子集组合

# 动态规划

<img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg" alt="image" style="zoom: 33%;" />

+ <span style="font-size:20px">概念：</span>

    动态规划即具有很多重叠子问题的问题

    动态规划中每一个状态一定是由上一个状态推导出来的

    **动态规划**是由前一个状态推导出来的，而**贪心算法**是局部直接选最优的

+ <span style="font-size:20px">步骤：</span>

    1. 确定 dp 数组(*dynamic programming table* )及下标含义
    2. 确定递推公式（每一个状态由上一个状态推导）
    3. dp 数组初始化
    4. 确定遍历顺序
    5. 举例推导 dp 数组



# 参考

+ 总：

    [代码随想录](https://programmercarl.com/)

