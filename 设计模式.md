# 单例模式

工厂模式每一次调用产生不同结果，单例模式与之相反，无论多少次调用获得的都是同一结果



1. 以下是一个用 **Class** 构建单例模式的例子：

    ```js
    class Window {
        static instance	
        constructor(){
        }
    
        static getInstance(){
            if(!Window.instance){	// 第一次调用时，`instance`是`undefined` 
                Window.instance = new Window()
            }
            return Window.instance
        }
    }
    
    let w1 = Window.getInstance()
    let w2 = Window.getInstance()
    console.log(w1 === w2);	// true
    ```

    > **类的静态属性**：
    >
    > 由`static`定义，指的是 Class 本身的属性，而不是定义在实例对象（`this`）上的属性

2. 用 **函数** 构建单例模式

```js
function Window(){
}

Window.getInstance = (function(){	// `.getInstance`得到的是该匿名函数返回的第10行 fn
    let window;	// 利用闭包，类似于上例的`static`
  	// 第5行代码只会在第一次调用`.getInstance`时运行
    return function(){
        if(!window){
            window = new Window()	// 调第1行`Window`函数
        }
        return window
    }
})()

let t1 = Window.getInstance()   // Window {}
let t2 = Window.getInstance()
console.log(t1 === t2);
```





# 适配器模式

